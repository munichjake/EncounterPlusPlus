import React, { useEffect, useMemo, useState, useRef } from "react";
import MonsterManager from "./components/MonsterManager.jsx";
import FantasticDiceRoller from "./components/FantasticDiceRoller.jsx";
import DiceRollerDDDice from "./components/DiceRollerDDDice.jsx";
import Login from "./components/Login.jsx";
import { useAuth } from "./contexts/AuthContext.jsx";
import { API, apiGet, apiPost, apiPut, apiDelete } from "./utils/api.js";
import { normalizeCreatureForForm } from "./utils/creatureNormalizer.js";
import { PlayerCharacterTab } from "./components/PlayerCharacterTab.jsx";
import { CompactParticipantRow } from "./components/CompactParticipantRow.jsx";
import { useModal } from "./components/Modal.jsx";
import { Settings, useSettings } from "./components/Settings.jsx";
import { initializeDiceRoller, rollDice } from "./utils/diceRoller.js";
import { ThreeDDice, ThreeDDiceAPI } from "dddice-js";
import CampaignManager from "./components/CampaignManager.jsx";
import EncounterTreeView from "./components/EncounterTreeView.jsx";

// jQuery and Select2 are loaded via CDN in index.html

// Adjective pool for naming duplicate creatures (50+ adjectives)
const CREATURE_ADJECTIVES = [
  "Brave", "Cunning", "Fierce", "Swift", "Mighty", "Clever", "Deadly", "Ancient",
  "Young", "Old", "Wise", "Foolish", "Angry", "Happy", "Sad", "Grumpy", "Cheerful",
  "Evil", "Good", "Chaotic", "Lawful", "Sneaky", "Bold", "Timid", "Cruel", "Kind",
  "Brutal", "Gentle", "Wild", "Tame", "Hungry", "Sleepy", "Alert", "Lazy", "Eager",
  "Reluctant", "Zealous", "Cowardly", "Noble", "Wicked", "Blessed", "Cursed", "Lucky",
  "Unlucky", "Scarred", "Pristine", "Battered", "Fresh", "Weary", "Energetic", "Stealthy",
  "Loud", "Silent", "Howling", "Whispering", "Blazing", "Frozen", "Toxic", "Radiant",
  "Shadow", "Bright", "Dark", "Pale", "Crimson", "Azure", "Golden", "Silver", "Iron",
  "Stone", "Crystal", "Ethereal", "Spectral", "Ghostly", "Demonic", "Angelic", "Feral",
  "Rabid", "Calm", "Frenzied", "Stoic", "Manic", "Serene", "Vicious", "Docile", "Proud"
];

// Get a random adjective that hasn't been used yet for this creature type
function getUniqueAdjective(baseName, existingNames) {
  const usedAdjectives = existingNames
    .filter(name => name.includes(baseName))
    .map(name => name.replace(baseName, '').trim())
    .filter(adj => CREATURE_ADJECTIVES.includes(adj));

  const availableAdjectives = CREATURE_ADJECTIVES.filter(adj => !usedAdjectives.includes(adj));

  if (availableAdjectives.length === 0) {
    // If all adjectives used, start adding numbers
    const maxNumber = existingNames
      .filter(name => name.includes(baseName))
      .map(name => {
        const match = name.match(/(\d+)$/);
        return match ? parseInt(match[1]) : 0;
      })
      .reduce((max, num) => Math.max(max, num), 0);
    return `${CREATURE_ADJECTIVES[Math.floor(Math.random() * CREATURE_ADJECTIVES.length)]} ${maxNumber + 1}`;
  }

  return availableAdjectives[Math.floor(Math.random() * availableAdjectives.length)];
}

// Source abbreviation vocabulary with colors
const SOURCE_VOCAB = {
  MM: { name: "Monster Manual", color: "red" },
  BGDIA: { name: "Baldur's Gate: Descent into Avernus", color: "orange" },
  VGM: { name: "Volo's Guide to Monsters", color: "amber" },
  MTF: { name: "Mordenkainen's Tome of Foes", color: "yellow" },
  MPMM: {
    name: "Mordenkainen Presents: Monsters of the Multiverse",
    color: "lime",
  },
  PHB: { name: "Player's Handbook", color: "green" },
  DMG: { name: "Dungeon Master's Guide", color: "emerald" },
  XPHB: { name: "Player's Handbook (2024)", color: "teal" },
  XDMG: { name: "Dungeon Master's Guide (2024)", color: "cyan" },
  XMM: { name: "Monster Manual (2024)", color: "sky" },
  VRGR: { name: "Van Richten's Guide to Ravenloft", color: "blue" },
  TCE: { name: "Tasha's Cauldron of Everything", color: "indigo" },
  XGE: { name: "Xanathar's Guide to Everything", color: "violet" },
  FTD: { name: "Fizban's Treasury of Dragons", color: "purple" },
  MGELFT: { name: "Mordenkainen's Fiendish Folio", color: "fuchsia" },
  TOA: { name: "Tomb of Annihilation", color: "pink" },
  SKT: { name: "Storm King's Thunder", color: "rose" },
  OOTA: { name: "Out of the Abyss", color: "red" },
  PotA: { name: "Princes of the Apocalypse", color: "orange" },
  HotDQ: { name: "Hoard of the Dragon Queen", color: "amber" },
  RoT: { name: "The Rise of Tiamat", color: "yellow" },
  CoS: { name: "Curse of Strahd", color: "lime" },
  LMoP: { name: "Lost Mine of Phandelver", color: "green" },
  GoS: { name: "Ghosts of Saltmarsh", color: "emerald" },
  DIP: { name: "Dragon of Icespire Peak", color: "teal" },
  SLW: { name: "Storm Lord's Wrath", color: "cyan" },
  SDW: { name: "Sleeping Dragon's Wake", color: "sky" },
  DC: { name: "Divine Contention", color: "blue" },
  ERLW: { name: "Eberron: Rising from the Last War", color: "indigo" },
  EGW: { name: "Explorer's Guide to Wildemount", color: "violet" },
  MOT: { name: "Mythic Odysseys of Theros", color: "purple" },
  IDRotF: { name: "Icewind Dale: Rime of the Frostmaiden", color: "fuchsia" },
  CM: { name: "Candlekeep Mysteries", color: "pink" },
  WBtW: { name: "The Wild Beyond the Witchlight", color: "rose" },
  CRCotN: { name: "Critical Role: Call of the Netherdeep", color: "red" },
  JttRC: { name: "Journeys through the Radiant Citadel", color: "orange" },
  DSotDQ: { name: "Dragonlance: Shadow of the Dragon Queen", color: "amber" },
  KftGV: { name: "Keys from the Golden Vault", color: "yellow" },
  BMT: { name: "The Book of Many Things", color: "lime" },
  PaBTSO: {
    name: "Phandelver and Below: The Shattered Obelisk",
    color: "green",
  },
  SatO: { name: "Spelljammer: Adventures in Space", color: "emerald" },
  AAG: { name: "Astral Adventurer's Guide", color: "teal" },
  BAM: { name: "Boo's Astral Menagerie", color: "cyan" },
  LLoK: { name: "Lost Laboratory of Kwalish", color: "sky" },
  GGR: { name: "Guildmasters' Guide to Ravnica", color: "blue" },
  AI: { name: "Acquisitions Incorporated", color: "indigo" },
  OGA: { name: "One Grung Above", color: "violet" },
  TFTYP: { name: "Tales from the Yawning Portal", color: "purple" },
  WDH: { name: "Waterdeep: Dragon Heist", color: "fuchsia" },
  WDMM: { name: "Waterdeep: Dungeon of the Mad Mage", color: "pink" },
};

// Helper function to get color classes for a source
function getSourceColorClasses(source) {
  const colorMap = {
    red: "bg-red-100 dark:bg-red-900/40 text-red-800 dark:text-red-300 border-red-300 dark:border-red-700",
    orange:
      "bg-orange-100 dark:bg-orange-900/40 text-orange-800 dark:text-orange-300 border-orange-300 dark:border-orange-700",
    amber:
      "bg-amber-100 dark:bg-amber-900/40 text-amber-800 dark:text-amber-300 border-amber-300 dark:border-amber-700",
    yellow:
      "bg-yellow-100 dark:bg-yellow-900/40 text-yellow-800 dark:text-yellow-300 border-yellow-300 dark:border-yellow-700",
    lime: "bg-lime-100 dark:bg-lime-900/40 text-lime-800 dark:text-lime-300 border-lime-300 dark:border-lime-700",
    green:
      "bg-green-100 dark:bg-green-900/40 text-green-800 dark:text-green-300 border-green-300 dark:border-green-700",
    emerald:
      "bg-emerald-100 dark:bg-emerald-900/40 text-emerald-800 dark:text-emerald-300 border-emerald-300 dark:border-emerald-700",
    teal: "bg-teal-100 dark:bg-teal-900/40 text-teal-800 dark:text-teal-300 border-teal-300 dark:border-teal-700",
    cyan: "bg-cyan-100 dark:bg-cyan-900/40 text-cyan-800 dark:text-cyan-300 border-cyan-300 dark:border-cyan-700",
    sky: "bg-sky-100 dark:bg-sky-900/40 text-sky-800 dark:text-sky-300 border-sky-300 dark:border-sky-700",
    blue: "bg-blue-100 dark:bg-blue-900/40 text-blue-800 dark:text-blue-300 border-blue-300 dark:border-blue-700",
    indigo:
      "bg-indigo-100 dark:bg-indigo-900/40 text-indigo-800 dark:text-indigo-300 border-indigo-300 dark:border-indigo-700",
    violet:
      "bg-violet-100 dark:bg-violet-900/40 text-violet-800 dark:text-violet-300 border-violet-300 dark:border-violet-700",
    purple:
      "bg-purple-100 dark:bg-purple-900/40 text-purple-800 dark:text-purple-300 border-purple-300 dark:border-purple-700",
    fuchsia:
      "bg-fuchsia-100 dark:bg-fuchsia-900/40 text-fuchsia-800 dark:text-fuchsia-300 border-fuchsia-300 dark:border-fuchsia-700",
    pink: "bg-pink-100 dark:bg-pink-900/40 text-pink-800 dark:text-pink-300 border-pink-300 dark:border-pink-700",
    rose: "bg-rose-100 dark:bg-rose-900/40 text-rose-800 dark:text-rose-300 border-rose-300 dark:border-rose-700",
  };

  const sourceData = SOURCE_VOCAB[source];
  const color = sourceData?.color || "blue";
  return colorMap[color] || colorMap["blue"];
}

function numberOr(v, d = 0) {
  const n = Number(v);
  return Number.isFinite(n) ? n : d;
}

// Helper function to process spell entries that might be strings or {choose} objects
function processSpellEntry(spellRaw) {
  // If it's a string, process normally
  if (typeof spellRaw === 'string') {
    return {
      type: 'spell',
      name: spellRaw
        .replace(/\{@spell ([^}|]+)(?:\|[^}]+)?\}/gi, "$1")
        .replace(/\*/g, "")
        .trim()
    };
  }

  // If it's a {choose} object
  if (typeof spellRaw === 'object' && spellRaw?.choose) {
    return {
      type: 'choose',
      count: spellRaw.choose.count,
      from: spellRaw.choose.from
    };
  }

  // Fallback for unknown formats
  return {
    type: 'unknown',
    raw: spellRaw
  };
}

// Helper function to extract spell names from various formats
function extractSpellNames(spellcastingArray) {
  const spellNames = [];

  if (!spellcastingArray || !Array.isArray(spellcastingArray))
    return spellNames;

  spellcastingArray.forEach((spellInfo) => {
    // Format 1: spellsByLevel
    if (spellInfo.spellsByLevel && Array.isArray(spellInfo.spellsByLevel)) {
      spellInfo.spellsByLevel.forEach((levelData) => {
        // Support both 'list' and 'spells' formats
        const spellList = levelData.list || levelData.spells;
        if (spellList && Array.isArray(spellList)) {
          spellList.forEach((spellRaw) => {
            const spellName = spellRaw
              .replace(/\{@spell ([^}|]+)(?:\|[^}]+)?\}/gi, "$1")
              .replace(/\*/g, "")
              .trim();
            spellNames.push(spellName);
          });
        }
      });
    }

    // Format 2: will (at will)
    if (spellInfo.will && Array.isArray(spellInfo.will)) {
      spellInfo.will.forEach((spellRaw) => {
        const spellName = spellRaw
          .replace(/\{@spell ([^}|]+)(?:\|[^}]+)?\}/gi, "$1")
          .replace(/\*/g, "")
          .trim();
        spellNames.push(spellName);
      });
    }

    // Format 3: daily
    if (spellInfo.daily) {
      Object.values(spellInfo.daily).forEach((spellList) => {
        if (Array.isArray(spellList)) {
          spellList.forEach((spellRaw) => {
            const spellName = spellRaw
              .replace(/\{@spell ([^}|]+)(?:\|[^}]+)?\}/gi, "$1")
              .replace(/\*/g, "")
              .trim();
            spellNames.push(spellName);
          });
        }
      });
    }
  });

  return [...new Set(spellNames)]; // Remove duplicates
}

// Calculate spell slots for a given caster level and spell level
function getSpellSlotsForLevel(casterLevel, spellLevel) {
  // D&D 5e spell slot progression table
  const slotTable = {
    1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
    2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
    3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
    4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
    5: [4, 3, 2, 0, 0, 0, 0, 0, 0],
    6: [4, 3, 3, 0, 0, 0, 0, 0, 0],
    7: [4, 3, 3, 1, 0, 0, 0, 0, 0],
    8: [4, 3, 3, 2, 0, 0, 0, 0, 0],
    9: [4, 3, 3, 3, 1, 0, 0, 0, 0],
    10: [4, 3, 3, 3, 2, 0, 0, 0, 0],
    11: [4, 3, 3, 3, 2, 1, 0, 0, 0],
    12: [4, 3, 3, 3, 2, 1, 0, 0, 0],
    13: [4, 3, 3, 3, 2, 1, 1, 0, 0],
    14: [4, 3, 3, 3, 2, 1, 1, 0, 0],
    15: [4, 3, 3, 3, 2, 1, 1, 1, 0],
    16: [4, 3, 3, 3, 2, 1, 1, 1, 0],
    17: [4, 3, 3, 3, 2, 1, 1, 1, 1],
    18: [4, 3, 3, 3, 3, 1, 1, 1, 1],
    19: [4, 3, 3, 3, 3, 2, 1, 1, 1],
    20: [4, 3, 3, 3, 3, 2, 2, 1, 1],
  };

  if (spellLevel === 0) return null; // Cantrips don't have slots
  if (casterLevel < 1 || casterLevel > 20) return null;
  if (spellLevel < 1 || spellLevel > 9) return null;

  return slotTable[casterLevel][spellLevel - 1];
}

// Dice roller using crypto.getRandomValues for true randomness
function rollSingleDie(sides) {
  const array = new Uint32Array(1);
  crypto.getRandomValues(array);
  return (array[0] % sides) + 1;
}

function rollD20() {
  return rollSingleDie(20);
}

function parseDiceRoll(notation) {
  // Support formats like "2d6+3" or "1d20"
  const match = notation.match(/^(\d+)d(\d+)([+\-]\d+)?$/i);
  if (!match) return null;

  const count = parseInt(match[1]);
  const sides = parseInt(match[2]);
  const modifier = match[3] ? parseInt(match[3]) : 0;

  let total = modifier;
  const rolls = [];
  for (let i = 0; i < count; i++) {
    const roll = rollSingleDie(sides);
    rolls.push(roll);
    total += roll;
  }

  return { rolls, total, notation, modifier };
}

function SlotEditor({ slots, onChange }) {
  const [levels, setLevels] = useState(() =>
    Object.keys(slots || {})
      .map((l) => Number(l))
      .sort((a, b) => a - b)
  );
  useEffect(() => {
    setLevels(
      Object.keys(slots || {})
        .map((l) => Number(l))
        .sort((a, b) => a - b)
    );
  }, [slots]);
  return (
    <div className="space-y-2">
      {levels.map((l) => (
        <div key={l} className="flex items-center gap-2">
          <span className="w-10">L{l}</span>
          <input
            type="number"
            className="input"
            value={slots[l]?.current ?? 0}
            onChange={(e) =>
              onChange({
                ...slots,
                [l]: {
                  ...(slots[l] || { max: 0 }),
                  current: numberOr(e.target.value),
                },
              })
            }
          />
          <span>/</span>
          <input
            type="number"
            className="input"
            value={slots[l]?.max ?? 0}
            onChange={(e) =>
              onChange({
                ...slots,
                [l]: {
                  current: slots[l]?.current ?? 0,
                  max: numberOr(e.target.value),
                },
              })
            }
          />
          <button
            className="btn"
            onClick={() =>
              onChange({
                ...slots,
                [l]: {
                  current: Math.max(0, (slots[l]?.current ?? 0) - 1),
                  max: slots[l]?.max ?? 0,
                },
              })
            }
          >
            â€‘1
          </button>
          <button
            className="btn"
            onClick={() =>
              onChange({
                ...slots,
                [l]: {
                  current: Math.min(
                    slots[l]?.max ?? 0,
                    (slots[l]?.current ?? 0) + 1
                  ),
                  max: slots[l]?.max ?? 0,
                },
              })
            }
          >
            +1
          </button>
        </div>
      ))}
      <div className="flex gap-2">
        <input
          id="newlvl"
          className="input w-20"
          placeholder="Lvl"
          type="number"
        />
        <button
          className="btn"
          onClick={() => {
            const el = document.getElementById("newlvl");
            const lvl = Number(el.value);
            if (!Number.isFinite(lvl) || lvl <= 0) return;
            onChange({ ...(slots || {}), [lvl]: { current: 0, max: 0 } });
            el.value = "";
          }}
        >
          Level hinzufÃ¼gen
        </button>
      </div>
    </div>
  );
}

function useEncounter(id, onEncounterUpdate) {
  const [enc, setEnc] = useState(null);
  useEffect(() => {
    if (!id) return;

    // Skip API call for temporary IDs (optimistic creation)
    if (typeof id === 'string' && id.startsWith('temp_')) {
      // Create empty encounter structure for temporary ID
      setEnc({
        id: id,
        name: 'Encounter',
        combatants: {},
        initiativeOrder: [],
        round: 1,
        turnIndex: 0
      });
      return;
    }

    apiGet(`/api/encounters/${id}`)
      .then((r) => r.json())
      .then((data) => {
        // Normalize combatants to fix any object fields that should be primitives
        if (data && data.combatants) {
          const normalizedCombatants = {};
          Object.entries(data.combatants).forEach(([key, c]) => {
            normalizedCombatants[key] = {
              ...c,
              // Ensure hp and baseHP are numbers, not objects
              hp:
                typeof c.hp === "object"
                  ? c.hp?.average || c.hp?.formula || 0
                  : c.hp || 0,
              baseHP:
                typeof c.baseHP === "object"
                  ? c.baseHP?.average || c.baseHP?.formula || 0
                  : c.baseHP || 0,
              // Ensure ac is a number
              ac: typeof c.ac === "object" ? c.ac?.value || 10 : c.ac || 10,
              // Ensure senses is a string, not an object
              senses:
                typeof c.senses === "object" && c.senses !== null
                  ? Object.entries(c.senses)
                      .map(([key, val]) => `${key}: ${val}`)
                      .join(", ")
                  : c.senses,
            };
          });
          data.combatants = normalizedCombatants;
        }
        setEnc(data);
      })
      .catch((err) => {
        console.error('Failed to load encounter:', err);
        // Create empty encounter on error
        setEnc({
          id: id,
          name: 'Encounter',
          combatants: {},
          initiativeOrder: [],
          round: 1,
          turnIndex: 0
        });
      });
  }, [id]);
  const save = async (next) => {
    // Optimistic update: Update UI immediately
    const previous = enc;
    setEnc(next);

    // Update encounters list immediately (optimistic)
    if (onEncounterUpdate && next.id && next.name) {
      onEncounterUpdate(next.id, next.name);
    }

    // Background API call
    try {
      await apiPut(`/api/encounters/${id}`, next);
    } catch (err) {
      console.error('Failed to save encounter:', err);
      // Rollback on error
      setEnc(previous);
      if (onEncounterUpdate && previous.id && previous.name) {
        onEncounterUpdate(previous.id, previous.name);
      }
    }
  };
  return { enc, setEnc, save };
}

function sortByInitiative(enc, combatMode = true) {
  // Handle empty or incomplete encounter data (e.g., during optimistic creation)
  if (!enc || !enc.combatants) {
    return [];
  }

  if (!enc.initiativeOrder || enc.initiativeOrder.length === 0) {
    // Fallback: sort combatants by initiative, then by tie-breaker
    const entries = Object.values(enc.combatants);
    return entries.sort((a, b) => {
      const initDiff = (b.initiative ?? 0) - (a.initiative ?? 0);
      if (initDiff !== 0) return initDiff;
      return (b.initiativeTieBreaker ?? 0) - (a.initiativeTieBreaker ?? 0);
    });
  }

  // Map initiativeOrder to actual combatants or lair action markers
  return enc.initiativeOrder.map(id => {
    if (typeof id === 'object' && id.type === 'lair') {
      // This is a lair action marker - only show in combat mode
      if (!combatMode) {
        return null;
      }
      return {
        id: id.id,
        type: 'lair',
        initiative: id.initiative,
        initiativeTieBreaker: 0, // Lair actions always lose ties
        name: `ðŸ° Lair Actions`,
        isLairAction: true,
        visibleToPlayers: false, // Always hidden from players
      };
    } else {
      // Regular combatant
      return enc.combatants[id];
    }
  }).filter(Boolean); // Remove any undefined entries
}

// Helper function to capitalize first letter of each word
function capitalizeDefense(text) {
  if (!text) return text;
  return text.split(', ').map(item => {
    return item.trim().split(' ').map(word => {
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    }).join(' ');
  }).join(', ');
}

// Helper function to format action name with recharge notation
function formatActionName(name) {
  if (!name) return name;

  // Replace {@recharge N} with formatted text
  const rechargeMatch = name.match(/\{@recharge (\d+)\}/i);
  if (rechargeMatch) {
    const num = parseInt(rechargeMatch[1]);
    const range = num === 6 ? "6" : `${num}, 6`;
    return name.replace(/\{@recharge \d+\}/i, `(Recharge: ${range})`);
  }

  return name;
}

// Helper function to parse defense arrays with special formatting
// Returns an array of defense strings (to preserve grouping)
function parseDefenseArray(defenseArray) {
  if (!defenseArray) return undefined;
  if (!Array.isArray(defenseArray)) {
    // If it's already a string, split by comma and capitalize
    return defenseArray.split(',').map(item => capitalizeDefense(item.trim()));
  }
  // Empty array means no defenses - return undefined to hide section
  if (defenseArray.length === 0) {
    return undefined;
  }

  const parsed = defenseArray.map(item => {
    if (typeof item === 'string' && item.startsWith("['") && item.endsWith("']")) {
      // Special format: ['bludgeoning', 'piercing', 'slashing'] -> "bludgeoning, piercing, slashing from non-magical weapons"
      const inner = item.slice(2, -2); // Remove [' and ']
      const types = inner.split("', '");
      return capitalizeDefense(types.join(", ") + " from non-magical weapons");
    }
    return capitalizeDefense(item);
  });

  return parsed;
}

export default function App() {
  const { user, loading, logout } = useAuth();
  const { alert, confirm, prompt, initiativePrompt, modal } = useModal();

  // Unified HP change logic - always applies temp HP first for damage
  function applyHPChange(combatant, inputValue) {
    const trimmed = inputValue.trim();
    const currentHP = combatant.hp ?? 0;
    const currentTempHP = combatant.tempHP || 0;
    const maxHP = combatant.baseHP;

    if (trimmed.startsWith('+')) {
      // Healing - only affects normal HP
      const amount = parseInt(trimmed.substring(1)) || 0;
      return {
        hp: Math.min(maxHP, currentHP + amount)
      };
    } else if (trimmed.startsWith('-')) {
      // Damage - ALWAYS applies to temp HP first
      const damage = parseInt(trimmed.substring(1)) || 0;

      if (currentTempHP > 0) {
        if (damage <= currentTempHP) {
          // All damage absorbed by temp HP
          return {
            tempHP: currentTempHP - damage
          };
        } else {
          // Temp HP absorbed, rest goes to normal HP
          const remaining = damage - currentTempHP;
          return {
            tempHP: 0,
            hp: Math.max(0, currentHP - remaining)
          };
        }
      } else {
        // No temp HP, damage goes straight to normal HP
        return {
          hp: Math.max(0, currentHP - damage)
        };
      }
    } else {
      // Absolute value - set HP directly (doesn't touch temp HP)
      const amount = parseInt(trimmed) || 0;
      return {
        hp: Math.max(0, Math.min(maxHP, amount))
      };
    }
  }

  const [encounters, setEncounters] = useState([]);
  const [encountersLoading, setEncountersLoading] = useState(true);
  const [currentId, setCurrentId] = useState(null);
  const [selectedCombatantId, setSelectedCombatantId] = useState(null);
  const [combatMode, setCombatMode] = useState(false);
  const [diceRollResult, setDiceRollResult] = useState(null);
  const [showDiceRoller, setShowDiceRoller] = useState(false);
  const [diceRollerStep, setDiceRollerStep] = useState("select"); // 'select' or 'result'
  const [diceRollerInitialNotation, setDiceRollerInitialNotation] =
    useState(null);
  const [diceRollerAutoRoll, setDiceRollerAutoRoll] = useState(false);
  const [diceRollerInitialRollMode, setDiceRollerInitialRollMode] =
    useState("normal");
  const [diceRollerLabel, setDiceRollerLabel] = useState('');
  const [diceRollerCharacter, setDiceRollerCharacter] = useState('');
  const [selectedDice, setSelectedDice] = useState(null);
  const [showCreatureManager, setShowCreatureManager] = useState(false);
  const [editingCreature, setEditingCreature] = useState(null);
  const [creatureManagerInitialTab, setCreatureManagerInitialTab] =
    useState("browse");
  const [creatureManagerInitialSearch, setCreatureManagerInitialSearch] =
    useState("");
  const [showCampaignManager, setShowCampaignManager] = useState(false);
  const [campaigns, setCampaigns] = useState([]);
  const [selectedCampaignForBulkAdd, setSelectedCampaignForBulkAdd] = useState(null);
  const [isAddingCampaignPlayers, setIsAddingCampaignPlayers] = useState(false);
  const [allowDuplicates, setAllowDuplicates] = useState(false);
  const [encounterSearchTerm, setEncounterSearchTerm] = useState('');
  const [encounterFolderFilter, setEncounterFolderFilter] = useState('all');
  const [darkMode, setDarkMode] = useState(() => {
    const saved = localStorage.getItem("darkMode");
    return saved ? JSON.parse(saved) : false;
  });
  const [rollHistory, setRollHistory] = useState(() => {
    try {
      const saved = localStorage.getItem("rollHistory");
      return saved ? JSON.parse(saved) : [];
    } catch (error) {
      console.error("Failed to load roll history from localStorage:", error);
      return [];
    }
  });
  const [showRollHistory, setShowRollHistory] = useState(false);
  const [toastDismissTimer, setToastDismissTimer] = useState(null);
  const [showProfileMenu, setShowProfileMenu] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [selectedSpell, setSelectedSpell] = useState(null);
  const [showSpellModal, setShowSpellModal] = useState(false);
  const [spellTooltip, setSpellTooltip] = useState({ spell: null, x: 0, y: 0 });

  // Collapse states for panels
  const [encounterTreeCollapsed, setEncounterTreeCollapsed] = useState(false);
  const [quickActionsCollapsed, setQuickActionsCollapsed] = useState(false);
  const [activeSidebarPanel, setActiveSidebarPanel] = useState(null); // 'encounters', 'quickActions', 'players', null
  const [sidebarVisible, setSidebarVisible] = useState(true);
  const [monsterBrowserCollapsed, setMonsterBrowserCollapsed] = useState(false);
  const [sourceTooltip, setSourceTooltip] = useState({
    source: null,
    fullName: null,
    x: 0,
    y: 0,
  });
  const [combatantSpellCache, setCombatantSpellCache] = useState({}); // Cache spell data by combatant ID
  const [lairActionsCache, setLairActionsCache] = useState({}); // Cache lair actions by legendary group name
  const [initiativeTooltip, setInitiativeTooltip] = useState({
    show: false,
    x: 0,
    y: 0,
    roll: 0,
    bonus: 0,
    total: 0,
  }); // Custom tooltip for initiative
  const [acTooltip, setAcTooltip] = useState({
    show: false,
    x: 0,
    y: 0,
    ac: 0,
    armorType: null,
  }); // Custom tooltip for AC
  const [hpTooltip, setHpTooltip] = useState({
    show: false,
    x: 0,
    y: 0,
    current: 0,
    max: 0,
    hitDice: null,
  }); // Custom tooltip for HP
  const [diceContextMenu, setDiceContextMenu] = useState({
    show: false,
    x: 0,
    y: 0,
    notation: "",
    type: "damage",
    onRoll: null,
  }); // Context menu for dice rolls
  const settings = useSettings();

  // Callback to update encounters list when encounter name changes
  const updateEncounterInList = React.useCallback((encId, newName) => {
    setEncounters((prev) =>
      prev.map((e) => (e.id === encId ? { ...e, name: newName } : e))
    );
  }, []);

  const { enc, setEnc, save } = useEncounter(currentId, updateEncounterInList);
  const order = useMemo(() => (enc ? sortByInitiative(enc, combatMode) : []), [enc, combatMode]);
  const selectedCombatant = useMemo(() => {
    if (!enc || !selectedCombatantId) return null;

    // Check if it's a lair action marker
    if (selectedCombatantId.startsWith('lair_')) {
      // Find the lair action marker in the order
      return order.find(c => c.id === selectedCombatantId);
    }

    return enc.combatants[selectedCombatantId];
  }, [enc, selectedCombatantId, order]);

  const dddiceRef = useRef(null);
  const dddiceCanvasRef = useRef(null);
  const [dddiceReady, setDddiceReady] = useState(false);

  useEffect(() => {
    const initDddice = async () => {
      if (dddiceRef.current) return;
      const saved = localStorage.getItem("app-settings");
      let settings = { diceRollerType: "2d" };
      if (saved)
        try {
          settings = JSON.parse(saved);
        } catch (e) {}      if (settings.diceRollerType !== "3d") {        return;
      }
      try {
        const apiKey = import.meta.env.VITE_DDDICE_API_KEY || "";        if (!apiKey) return;
        const api = new ThreeDDiceAPI(apiKey, "Encounter++");
        let themeId = "dddice-standard";
        try {
          const box = await api.diceBox.list();
          if (box?.data?.[0]) themeId = box.data[0].id;        } catch (e) {}
        const room = await api.room.create();
        const slug = room?.data?.slug || room?.data?.id;        const canvas = document.createElement("canvas");
        canvas.style.cssText =
          "position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:45;pointer-events:none";
        document.body.appendChild(canvas);
        dddiceCanvasRef.current = canvas;
        const dddice = new ThreeDDice(canvas, apiKey);
        await dddice.start();
        await dddice.connect(slug);
        dddiceRef.current = { dddice, theme: themeId };
        setDddiceReady(true);
        window.__dddiceInstance = dddiceRef.current;
        window.__dddiceReady = true;      } catch (err) {
        console.error("âŒ dddice failed:", err);
      }
    };
    initDddice();
    const handleChange = (e) => {
      if (e.detail.diceRollerType === "3d" && !dddiceRef.current) initDddice();
      else if (e.detail.diceRollerType !== "3d" && dddiceRef.current) {
        dddiceRef.current.dddice.stop();
        dddiceRef.current = null;
        setDddiceReady(false);
        if (dddiceCanvasRef.current)
          document.body.removeChild(dddiceCanvasRef.current);
      }
    };
    window.addEventListener("settings-changed", handleChange);
    return () => window.removeEventListener("settings-changed", handleChange);
  }, []);

  // Handle roll function - defined at component level for use in JSX
  const handleRoll = ({ notation, label, character, rollMode, onResult }) => {
    setDiceRollerInitialNotation(notation);
    setDiceRollerLabel(label || '');
    setDiceRollerCharacter(character || '');
    setDiceRollerInitialRollMode(rollMode || "normal");
    setDiceRollerAutoRoll(true);
    setShowDiceRoller(true);

    // Store callback for when roll completes
    window.__diceRollerCallback = onResult;
  };

  // Initialize dice roller wrapper
  useEffect(() => {

    const handleAddHistory = (entry) => {
      // TODO: Add to history log
      console.log('History entry:', entry);
    };

    initializeDiceRoller(handleRoll, handleAddHistory, settings);
  }, [settings]);

  // Load and cache all spells for the selected combatant
  useEffect(() => {
    if (!selectedCombatant || !selectedCombatant.spellcasting) return;

    // Check if already cached
    if (combatantSpellCache[selectedCombatantId]) return;

    // Extract all spell names from all formats
    const spellNames = extractSpellNames(selectedCombatant.spellcasting);

    if (spellNames.length === 0) return;

    // Load all spells with delay to avoid rate limiting
    const loadSpells = async () => {
      try {
        // Helper function to add delay between requests
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Load spells sequentially with small delay
        const results = [];
        for (let i = 0; i < spellNames.length; i++) {
          const spellName = spellNames[i];
          try {
            const response = await apiGet(
              `/api/spells/${encodeURIComponent(spellName)}`
            );
            const spell = await response.json();
            results.push({ name: spellName, data: spell });
          } catch (error) {
            console.error(`Failed to load spell: ${spellName}`, error);
            results.push(null);
          }

          // Add 50ms delay between requests (except after the last one)
          if (i < spellNames.length - 1) {
            await delay(50);
          }
        }
        const spellsMap = {};

        results.forEach((result) => {
          if (result && result.data) {
            spellsMap[result.name.toLowerCase()] = result.data;
          }
        });

        // Categorize spells by casting time
        const categorized = {
          actions: [],
          bonusActions: [],
          reactions: [],
          other: [],
        };

        Object.entries(spellsMap).forEach(([name, spell]) => {
          // encounterpp format - castingTime is a string
          if (spell.castingTime) {
            const castingTime = spell.castingTime.toLowerCase();

            if (
              castingTime.includes("action") &&
              !castingTime.includes("bonus") &&
              !castingTime.includes("reaction")
            ) {
              categorized.actions.push({ name, spell });
            } else if (castingTime.includes("bonus")) {
              categorized.bonusActions.push({ name, spell });
            } else if (castingTime.includes("reaction")) {
              categorized.reactions.push({ name, spell });
            } else {
              categorized.other.push({ name, spell });
            }
            return;
          }

          // 5e.tools format fallback - time is an array of objects
          if (!spell.time || !spell.time[0]) {
            categorized.other.push({ name, spell });
            return;
          }

          const time = spell.time[0];
          const unit = time.unit?.toLowerCase() || "";
          const number = time.number || 1;

          if (unit === "action" && number === 1) {
            categorized.actions.push({ name, spell });
          } else if (unit === "bonus") {
            categorized.bonusActions.push({ name, spell });
          } else if (unit === "reaction") {
            categorized.reactions.push({ name, spell });
          } else {
            categorized.other.push({ name, spell });
          }
        });

        console.log("Spell categorization for", selectedCombatant.name, ":", {
          actions: categorized.actions.map((s) => s.name),
          bonusActions: categorized.bonusActions.map((s) => s.name),
          reactions: categorized.reactions.map((s) => s.name),
          other: categorized.other.map((s) => s.name),
        });

        setCombatantSpellCache((prev) => ({
          ...prev,
          [selectedCombatantId]: categorized,
        }));
      } catch (error) {
        console.error("Error loading spells:", error);
      }
    };

    loadSpells();
  }, [selectedCombatant, selectedCombatantId, combatantSpellCache]);

  // Load lair actions from legendary group
  useEffect(() => {
    if (!selectedCombatant || !selectedCombatant.legendaryGroup) return;

    const groupName = selectedCombatant.legendaryGroup.name || selectedCombatant.legendaryGroup;

    // Check if already cached
    if (lairActionsCache[groupName]) return;

    const loadLairActions = async () => {
      try {
        const response = await apiGet(`/api/legendary-groups/${encodeURIComponent(groupName)}`);
        const groupData = await response.json();

        setLairActionsCache((prev) => ({
          ...prev,
          [groupName]: groupData,
        }));
      } catch (error) {
        console.error("Error loading lair actions:", error);
      }
    };

    loadLairActions();
  }, [selectedCombatant, lairActionsCache]);

  // Auto-initialize spell slots from spellcasting data
  useEffect(() => {
    if (!selectedCombatant || !selectedCombatant.spellcasting) return;

    // Only initialize if spellSlots is empty or undefined
    if (
      selectedCombatant.spellSlots &&
      Object.keys(selectedCombatant.spellSlots).length > 0
    )
      return;

    const spellSlots = {};
    let foundSlots = false;

    selectedCombatant.spellcasting.forEach((spellInfo) => {
      // Check for spellsByLevel format (prepared spellcasters)
      if (spellInfo.spellsByLevel && Array.isArray(spellInfo.spellsByLevel)) {
        spellInfo.spellsByLevel.forEach((levelData) => {
          const level = levelData.level || 0;

          // Skip cantrips (level 0)
          if (level === 0) return;

          // Get slots from data or calculate from caster level
          let slots = levelData.slots;
          if (!slots && level > 0 && spellInfo.notes) {
            // Try to extract caster level from notes like "18th-level spellcaster"
            const levelMatch = spellInfo.notes.match(
              /(\d+)(?:st|nd|rd|th)-level spellcaster/i
            );
            if (levelMatch) {
              const casterLevel = parseInt(levelMatch[1]);
              slots = getSpellSlotsForLevel(casterLevel, level);
            }
          }

          if (slots && slots > 0) {
            spellSlots[level] = { max: slots, current: slots };
            foundSlots = true;
          }
        });
      }
    });

    // Update combatant with initialized spell slots
    if (foundSlots) {
      updateCombatant(selectedCombatant.id, { spellSlots });
    }
  }, [selectedCombatant]);

  useEffect(() => {    localStorage.setItem("darkMode", JSON.stringify(darkMode));
    if (darkMode) {
      document.documentElement.classList.add("dark");    } else {
      document.documentElement.classList.remove("dark");    }  }, [darkMode]);

  // Save roll history to localStorage whenever it changes
  useEffect(() => {
    try {
      localStorage.setItem("rollHistory", JSON.stringify(rollHistory));
    } catch (error) {
      console.error("Failed to save roll history to localStorage:", error);
    }
  }, [rollHistory]);

  useEffect(() => {
    // Wait for auth to finish loading before making API calls
    if (loading || !user) return;
    setEncountersLoading(true);
    apiGet("/api/encounters")
      .then((r) => r.json())
      .then((data) => {
        setEncounters(data);
        setEncountersLoading(false);
      })
      .catch((err) => {
        console.error('Failed to load encounters:', err);
        setEncountersLoading(false);
      });
  }, [user, loading]);

  // Close menus/modals when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      // Close profile menu
      if (showProfileMenu && !event.target.closest(".profile-menu-container")) {
        setShowProfileMenu(false);
      }

      // Close dice roller
      if (
        showDiceRoller &&
        !event.target.closest(".dice-roller-container") &&
        !event.target.closest(".dice-roller-button")
      ) {
        setShowDiceRoller(false);
      }

      // Close roll history
      if (
        showRollHistory &&
        !event.target.closest(".roll-history-container") &&
        !event.target.closest(".roll-history-button")
      ) {
        setShowRollHistory(false);
      }

      // Close creature manager
      if (
        showCreatureManager &&
        !event.target.closest(".creature-manager-container") &&
        !event.target.closest(".creature-manager-button")
      ) {
        setShowCreatureManager(false);
        setEditingCreature(null);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [showProfileMenu, showDiceRoller, showRollHistory, showCreatureManager]);

  // Handle Delete key to remove selected combatant
  useEffect(() => {
    const handleKeyDown = async (event) => {
      // Check if Delete or Backspace key is pressed
      if (
        (event.key === "Delete" || event.key === "Backspace") &&
        selectedCombatantId &&
        enc
      ) {
        // Don't trigger if user is typing in an input/textarea
        if (
          event.target.tagName === "INPUT" ||
          event.target.tagName === "TEXTAREA"
        ) {
          return;
        }

        event.preventDefault();

        const combatant = enc.combatants[selectedCombatantId];
        const confirmed = await confirm(
          `${
            combatant?.name || "Diesen Combatant"
          } wirklich aus der Liste entfernen?`
        );

        if (confirmed) {
          deleteCombatant(selectedCombatantId);
        }
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [selectedCombatantId, enc, confirm]);

  // Load campaigns
  useEffect(() => {
    // Wait for auth to finish loading before making API calls
    if (loading || !user) return;
    async function loadCampaigns() {
      try {
        const data = await apiGet('/api/campaigns');
        setCampaigns(await data.json());
      } catch (err) {
        console.error('Failed to load campaigns:', err);
      }
    }
    loadCampaigns();
  }, [user, loading]);

  // Show login screen if not authenticated
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500 mx-auto mb-4"></div>
          <p>Lade...</p>
        </div>
      </div>
    );
  }

  if (!user) {
    return <Login />;
  }

  async function createEncounter() {
    // Optimistic update: Create encounter immediately with temporary ID
    const tempId = `temp_${Date.now()}`;
    const optimisticEncounter = {
      id: tempId,
      name: "Encounter",
      updatedAt: new Date().toISOString()
    };

    setEncounters((prev) => [...prev, optimisticEncounter]);
    setCurrentId(tempId);

    // Background API call
    try {
      const r = await apiPost("/api/encounters", { name: "Encounter" });
      const created = await r.json();

      // Replace temporary encounter with real one
      setEncounters((prev) =>
        prev.map((e) => (e.id === tempId ? { id: created.id, name: created.name, updatedAt: created.updatedAt } : e))
      );
      setCurrentId(created.id);
    } catch (err) {
      console.error('Failed to create encounter:', err);
      // Rollback: Remove optimistic encounter
      setEncounters((prev) => prev.filter((e) => e.id !== tempId));
      setCurrentId(null);
    }
  }

  // Add all campaign players to encounter
  async function addCampaignPlayersToEncounter(campaignId) {
    if (!enc) {
      await alert('Bitte wÃ¤hle erst ein Encounter aus');
      return;
    }

    setIsAddingCampaignPlayers(true);
    try {
      const response = await apiGet(`/api/campaigns/${campaignId}/characters`);
      const characters = await response.json();

      if (characters.length === 0) {
        await alert('Diese Kampagne hat keine Spielercharaktere');
        setIsAddingCampaignPlayers(false);
        return;
      }

      const combatants = { ...enc.combatants };
      let addedCount = 0;
      let skippedCount = 0;

      characters.forEach((pc) => {
        // Check if character already exists (by name)
        const exists = Object.values(combatants).some(c => c.name === pc.name);

        if (!exists || allowDuplicates) {
          const id = crypto.randomUUID();
          combatants[id] = {
            id,
            name: pc.name,
            ac: pc.ac || 10,
            baseHP: pc.hp || 10,
            hp: pc.hp || 10,
            tempHP: 0,
            initiativeMod: pc.initiativeMod || 0,
            initiative: 0,
            initiativeTieBreaker: 0,
            player: true,
            notes: '',
            concentration: false,
            concentrationMod: 0,
            spellSlots: {},
            deathSaves: { successes: 0, failures: 0 },
            reactionUsed: false,
            sidekickOf: null,
          };
          addedCount++;
        } else {
          skippedCount++;
        }
      });

      // Save the updated encounter
      const updateResponse = await apiPut(`/api/encounters/${enc.id}`, {
        ...enc,
        combatants,
      });

      if (updateResponse.ok) {
        const updatedEnc = await updateResponse.json();
        setEnc(updatedEnc);

        let message = `${addedCount} Spieler hinzugefÃ¼gt`;
        if (skippedCount > 0) {
          message += `, ${skippedCount} bereits vorhanden (Ã¼bersprungen)`;
        }
        await alert(message);
      }
    } catch (err) {
      console.error('Failed to add campaign players:', err);
      await alert('Fehler beim HinzufÃ¼gen der Spieler');
    } finally {
      setIsAddingCampaignPlayers(false);
    }
  }

  async function importEncounter(file) {
    const text = await file.text();
    const payload = JSON.parse(text);
    const r = await apiPost("/api/import/encounter", payload);
    const created = await r.json();
    setEncounters((prev) => [
      ...prev,
      { id: created.id, name: created.name, updatedAt: created.updatedAt },
    ]);
    setCurrentId(created.id);
  }

  function updateCombatant(id, patch) {
    const combatant = enc.combatants[id];
    const oldHP = combatant.hp;
    const oldTempHP = combatant.tempHP || 0;
    const newHP = patch.hp !== undefined ? patch.hp : oldHP;
    const newTempHP = patch.tempHP !== undefined ? patch.tempHP : oldTempHP;

    // If baseHP is changing, adjust current HP proportionally (keep damage constant)
    if (patch.baseHP !== undefined && patch.baseHP !== combatant.baseHP) {
      const oldBaseHP = combatant.baseHP;
      const newBaseHP = patch.baseHP;
      const damage = oldBaseHP - oldHP; // How much damage has been taken
      const newCurrentHP = Math.max(0, newBaseHP - damage); // Apply same damage to new max
      patch = { ...patch, hp: newCurrentHP };
    }

    // Check for concentration break on damage (when HP or tempHP decreases)
    if (combatant.concentration && (newHP < oldHP || newTempHP < oldTempHP)) {
      // Calculate total damage taken (from both HP and tempHP)
      const hpDamage = oldHP - newHP;
      const tempHPDamage = oldTempHP - newTempHP;
      const damage = Math.max(hpDamage, tempHPDamage, hpDamage + tempHPDamage);

      const dc = Math.max(10, Math.floor(damage / 2));
      const roll = rollD20();
      const conMod = combatant.concentrationMod || 0;
      const total = roll + conMod;

      const passed = total >= dc;
      setDiceRollResult({
        type: "concentration",
        name: combatant.name,
        roll,
        modifier: conMod,
        total,
        dc,
        passed,
      });

      if (!passed) {
        patch = { ...patch, concentration: false };
      }
    }

    const next = {
      ...enc,
      combatants: {
        ...enc.combatants,
        [id]: { ...enc.combatants[id], ...patch },
      },
    };

    // If initiative was changed and this combatant has sidekicks, sync them
    if (patch.initiative !== undefined) {
      Object.values(next.combatants).forEach(c => {
        if (c.sidekickOf === id) {
          next.combatants[c.id] = {
            ...c,
            initiative: patch.initiative,
            initiativeTieBreaker: (patch.initiativeTieBreaker || 0) - 0.5
          };
        }
      });
    }

    // If this is a sidekick and its assignment changed, sync initiative
    if (patch.sidekickOf !== undefined && patch.sidekickOf) {
      const assignedPlayer = next.combatants[patch.sidekickOf];
      if (assignedPlayer && assignedPlayer.initiative !== undefined) {
        next.combatants[id] = {
          ...next.combatants[id],
          initiative: assignedPlayer.initiative,
          initiativeTieBreaker: (assignedPlayer.initiativeTieBreaker || 0) - 0.5
        };
      }
    }

    next.initiativeOrder = Object.values(next.combatants)
      .sort((a, b) => {
        const initDiff = (b.initiative ?? 0) - (a.initiative ?? 0);
        if (initDiff !== 0) return initDiff;
        return (b.initiativeTieBreaker ?? 0) - (a.initiativeTieBreaker ?? 0);
      })
      .map((c) => c.id);
    save(next);
  }

  function applyDamage(id, damage) {
    const c = enc.combatants[id];
    const tempHP = c.tempHP || 0;

    if (tempHP > 0) {
      const remainingDamage = damage - tempHP;
      if (remainingDamage <= 0) {
        updateCombatant(id, { tempHP: tempHP - damage });
      } else {
        updateCombatant(id, {
          tempHP: 0,
          hp: Math.max(0, c.hp - remainingDamage),
        });
      }
    } else {
      updateCombatant(id, { hp: Math.max(0, c.hp - damage) });
    }
  }

  async function deleteCombatant(id) {
    if (!enc) return;

    // Remove the combatant from the combatants object
    const { [id]: removed, ...remainingCombatants } = enc.combatants;

    // Check if the removed combatant had lair actions
    const removedHadLairActions = removed?.legendaryGroup;

    // If removed combatant had lair actions, check if any remaining combatants have the same legendary group
    let shouldRemoveLairMarkers = false;
    if (removedHadLairActions) {
      const removedGroupName = removed.legendaryGroup.name || removed.legendaryGroup;
      const otherWithSameLair = Object.values(remainingCombatants).some(c => {
        const groupName = c.legendaryGroup?.name || c.legendaryGroup;
        return groupName === removedGroupName;
      });
      shouldRemoveLairMarkers = !otherWithSameLair;
    }

    // Remove from initiative order (and lair action markers if needed)
    const newInitiativeOrder = enc.initiativeOrder.filter((cid) => {
      // Always remove the deleted combatant
      if (cid === id) return false;

      // Remove lair action markers if no more creatures have lair actions
      if (shouldRemoveLairMarkers && typeof cid === 'object' && cid.type === 'lair') {
        return false;
      }

      return true;
    });

    // Adjust turnIndex if necessary
    let newTurnIndex = enc.turnIndex;
    if (
      newTurnIndex >= newInitiativeOrder.length &&
      newInitiativeOrder.length > 0
    ) {
      newTurnIndex = newInitiativeOrder.length - 1;
    }

    // Clear selection if the deleted combatant was selected
    if (selectedCombatantId === id) {
      setSelectedCombatantId(null);
    }

    save({
      ...enc,
      combatants: remainingCombatants,
      initiativeOrder: newInitiativeOrder,
      turnIndex: newTurnIndex,
    });
  }

  async function rollInitiativeForAll() {
    const updated = { ...enc };
    const combatants = Object.values(updated.combatants);

    // Separate PCs from monsters
    const playerCharacters = combatants.filter(
      (c) => c.isPC || c.source === "ddb-import" || c.source === "player-character"
    );
    const monsters = combatants.filter(
      (c) => !c.isPC && c.source !== "ddb-import" && c.source !== "player-character"
    );

    // Auto-roll initiative for monsters (excluding sidekicks - they'll be handled later)
    monsters.filter(c => !c.sidekickOf).forEach((c) => {
      const roll = rollD20();
      const init = roll + (c.initiativeMod || 0);
      updated.combatants[c.id] = { ...c, initiative: init, initiativeRoll: roll };
    });

    // Show modal for player characters if there are any
    if (playerCharacters.length > 0) {      const initiatives = await initiativePrompt(playerCharacters);
      // If user cancelled, don't update anything
      if (!initiatives) return;

      // Apply the initiative values from the modal
      Object.entries(initiatives).forEach(([id, initiative]) => {
        updated.combatants[id] = { ...updated.combatants[id], initiative };
      });
    }

    // Sync sidekick initiatives with their assigned players
    combatants.filter(c => c.sidekickOf).forEach((sidekick) => {
      const assignedPlayer = updated.combatants[sidekick.sidekickOf];
      if (assignedPlayer && assignedPlayer.initiative !== undefined) {
        updated.combatants[sidekick.id] = {
          ...sidekick,
          initiative: assignedPlayer.initiative,
          initiativeTieBreaker: (assignedPlayer.initiativeTieBreaker || 0) - 0.5 // Sidekick goes slightly after player
        };
      }
    });

    // Sort initiative order (by initiative, then by tie-breaker descending)
    const sortedCombatants = Object.values(updated.combatants)
      .sort((a, b) => {
        const initDiff = (b.initiative ?? 0) - (a.initiative ?? 0);
        if (initDiff !== 0) return initDiff;
        // If initiative is the same, sort by tie-breaker (higher goes first)
        return (b.initiativeTieBreaker ?? 0) - (a.initiativeTieBreaker ?? 0);
      });

    // Load lair actions for any combatants that have legendary groups
    const loadedLairActions = { ...lairActionsCache };
    const lairActionsToLoad = [];
    for (const combatant of sortedCombatants) {
      if (combatant.legendaryGroup) {
        const groupName = combatant.legendaryGroup.name || combatant.legendaryGroup;
        if (!loadedLairActions[groupName]) {
          lairActionsToLoad.push(groupName);
        }
      }
    }

    // Load all missing lair actions before proceeding
    if (lairActionsToLoad.length > 0) {
      for (const groupName of lairActionsToLoad) {
        try {
          const response = await apiGet(`/api/legendary-groups/${encodeURIComponent(groupName)}`);
          const groupData = await response.json();
          loadedLairActions[groupName] = groupData;
        } catch (error) {
          console.error(`Error loading lair actions for ${groupName}:`, error);
        }
      }
      // Update the cache state
      setLairActionsCache(loadedLairActions);
    }

    // Check if any combatants have lair actions
    const lairActionInitiatives = new Set();
    for (const combatant of sortedCombatants) {
      if (combatant.legendaryGroup) {
        const groupName = combatant.legendaryGroup.name || combatant.legendaryGroup;
        const groupData = loadedLairActions[groupName];
        if (groupData?.lairActions && groupData.lairActions.length > 0) {
          // Parse initiative count from lair actions
          const firstAction = typeof groupData.lairActions[0] === 'string' ? groupData.lairActions[0] : '';
          const initiativeMatch = firstAction.match(/initiative count (\d+)/i);
          const initiativeCount = initiativeMatch ? parseInt(initiativeMatch[1]) : 20;
          lairActionInitiatives.add(initiativeCount);
        }
      }
    }

    // Build initiative order with lair action markers
    // Lair actions lose initiative ties (come after creatures with the same initiative)
    const initiativeOrder = [];
    for (const combatant of sortedCombatants) {
      // Check if we need to insert a lair action marker before this combatant
      for (const lairInit of lairActionInitiatives) {
        // Lair actions are inserted AFTER creatures with the SAME initiative (lose ties)
        if (combatant.initiative <= lairInit &&
            !initiativeOrder.some(id => typeof id === 'object' && id.type === 'lair' && id.initiative === lairInit)) {
          // Check if this is the last combatant with this initiative or higher
          const nextCombatantIndex = sortedCombatants.indexOf(combatant) + 1;
          const nextCombatant = sortedCombatants[nextCombatantIndex];

          // Insert lair action if:
          // - there's no next combatant, OR
          // - next combatant has lower initiative than lair action
          if (!nextCombatant || nextCombatant.initiative < lairInit) {
            initiativeOrder.push({ type: 'lair', initiative: lairInit, id: `lair_${lairInit}` });
          }
        }
      }
      initiativeOrder.push(combatant.id);
    }

    // Add any remaining lair actions at the end (if initiative is lower than all combatants)
    for (const lairInit of lairActionInitiatives) {
      if (!initiativeOrder.some(id => typeof id === 'object' && id.type === 'lair' && id.initiative === lairInit)) {
        initiativeOrder.push({ type: 'lair', initiative: lairInit, id: `lair_${lairInit}` });
      }
    }

    updated.initiativeOrder = initiativeOrder;

    save(updated);
  }

  async function resetCombat() {
    if (
      !(await confirm(
        "MÃ¶chtest du den Combat zurÃ¼cksetzen? Alle Initiative-Werte, HP-Ã„nderungen und Conditions werden zurÃ¼ckgesetzt."
      ))
    )
      return;

    const updated = { ...enc };

    // Reset all combatants
    Object.values(updated.combatants).forEach((c) => {
      updated.combatants[c.id] = {
        ...c,
        initiative: undefined,
        currentHp: c.hp || c.maxHp,
        tempHp: 0,
        conditions: [],
      };
    });

    // Reset combat state
    updated.round = 1;
    updated.turnIndex = 0;
    updated.initiativeOrder = [];

    save(updated);
  }

  async function deleteEncounter(id) {
    if (!(await confirm("MÃ¶chtest du dieses Encounter wirklich lÃ¶schen?")))
      return;

    // Save for rollback
    const deletedEncounter = encounters.find(e => e.id === id);
    const wasCurrentId = currentId === id;

    // Optimistic update: Remove from list immediately
    setEncounters((prev) => prev.filter((e) => e.id !== id));
    if (wasCurrentId) setCurrentId(null);

    // Background API call
    try {
      await apiDelete(`/api/encounters/${id}`);
    } catch (err) {
      console.error('Failed to delete encounter:', err);
      // Rollback: Restore encounter
      if (deletedEncounter) {
        setEncounters((prev) => [...prev, deletedEncounter]);
        if (wasCurrentId) setCurrentId(id);
      }
    }
  }

  async function addMonster(mon) {
    // Check if an encounter is loaded
    if (!enc) {
      await alert("Bitte erstelle oder wÃ¤hle zuerst ein Encounter aus.");
      return;
    }

    const id = crypto.randomUUID();
    // Handle HP - could be a number or an object with {formula, average}
    const hpValue =
      typeof mon.hp === "object" && mon.hp !== null
        ? mon.hp.average || mon.hpAvg || 0
        : mon.hp || mon.hpAvg || 0;
    const hpFormula =
      typeof mon.hp === "object" && mon.hp !== null
        ? mon.hp.formula || null
        : null;
    // Handle AC - could be a number, an object with {value, notes}, or an array of AC objects
    let acValue = 10; // Default AC
    let acFrom = null; // AC source (armor type, natural armor, etc.)
    if (Array.isArray(mon.ac) && mon.ac.length > 0) {
      // AC is an array - take the first entry's value and notes
      acValue = mon.ac[0].value || mon.ac[0].ac || 10;
      // Extract notes and parse {@item ...} tags
      if (mon.ac[0].notes) {
        let notes = mon.ac[0].notes;
        // Remove {@item ...} tags and extract item names
        notes = notes.replace(/\{@item ([^|]+)(?:\|[^}]+)?\}/g, '$1');
        acFrom = [notes.trim()];
      } else if (mon.ac[0].from) {
        acFrom = Array.isArray(mon.ac[0].from) ? mon.ac[0].from : [mon.ac[0].from];
      }
    } else if (typeof mon.ac === "object" && mon.ac !== null) {
      // AC is an object
      acValue = mon.ac.value || mon.ac.ac || 10;
      if (mon.ac.notes) {
        let notes = mon.ac.notes;
        notes = notes.replace(/\{@item ([^|]+)(?:\|[^}]+)?\}/g, '$1');
        acFrom = [notes.trim()];
      } else if (mon.ac.from) {
        acFrom = Array.isArray(mon.ac.from) ? mon.ac.from : [mon.ac.from];
      }
    } else if (typeof mon.ac === "number") {
      // AC is a plain number
      acValue = mon.ac;
    }

    // Calculate initiative modifier from DEX
    const dexValue = mon.abilities?.dex || mon.dex || 10;
    const initiativeModValue = mon.initiativeMod ?? Math.floor((dexValue - 10) / 2);

    // Handle speed - could be a string or an object
    let speedValue = "";
    let flySpeed = null;
    let swimSpeed = null;
    let climbSpeed = null;
    let burrowSpeed = null;

    if (typeof mon.speed === "object" && mon.speed !== null) {
      // Extract all speed types from object
      speedValue = mon.speed.walk || "";
      flySpeed = mon.speed.fly || null;
      swimSpeed = mon.speed.swim || null;
      climbSpeed = mon.speed.climb || null;
      burrowSpeed = mon.speed.burrow || null;
    } else {
      // Plain string or number
      speedValue = mon.speed || mon.spd || "";
    }
    // Handle senses - could be a string or an object with {darkvision, passivePerception}
    const sensesValue =
      typeof mon.senses === "object" && mon.senses !== null
        ? Object.entries(mon.senses)
            .map(([key, val]) => `${key}: ${val}`)
            .join(", ")
        : mon.senses ||
          (mon.darkvision ? `Darkvision ${mon.darkvision} ft.` : "");

    // Auto-generate unique name with adjective if duplicate exists
    const baseName = mon.name || mon.n;
    const existingNames = Object.values(enc.combatants).map(c => c.name);
    const nameCount = existingNames.filter(name =>
      name === baseName || name.endsWith(baseName)
    ).length;

    let finalName = baseName;
    if (nameCount > 0) {
      // Duplicate detected - add adjective to new creature
      const adjective = getUniqueAdjective(baseName, existingNames);
      finalName = `${adjective} ${baseName}`;

      // Also add adjective to the first creature if it doesn't have one yet
      const firstCreature = Object.values(enc.combatants).find(c => c.name === baseName);
      if (firstCreature) {
        const firstAdjective = getUniqueAdjective(baseName, [...existingNames, finalName]);
        firstCreature.name = `${firstAdjective} ${baseName}`;
      }
    }

    // Create combatant with selective monster data (avoid copying object fields that break React rendering)
    const c = {
      // Combat-specific fields
      id,
      initiative: 0,
      initiativeTieBreaker: 0,
      hp: hpValue,
      baseHP: hpValue,
      hpFormula: hpFormula,
      tempHP: 0,
      player: false,
      notes: "",
      concentration: false,
      concentrationMod: 0,
      spellSlots: {},
      deathSaves: { successes: 0, failures: 0 },
      sidekickOf: null, // ID of player this is a sidekick for
      // Legendary action points tracking
      legendaryPoints: mon.legendary?.pts || mon.legendary?.points || 0,
      legendaryPointsMax: mon.legendary?.pts || mon.legendary?.points || 0,
      // Reaction tracking (boolean: has reaction been used this round?)
      reactionUsed: false,
      // Basic info
      name: finalName,
      ac: acValue,
      acFrom: acFrom,
      initiativeMod: initiativeModValue,
      // Map 5e.tools compact format to full format
      size: mon.size || mon.sz,
      type: mon.type || mon.t,
      alignment: mon.alignment || mon.al,
      cr: mon.cr,
      source: mon.source || mon.src || mon.meta?.source,
      meta: mon.meta,
      // Ability scores - check both abilities.str and direct str fields
      str: mon.abilities?.str || mon.str,
      dex: mon.abilities?.dex || mon.dex,
      con: mon.abilities?.con || mon.con,
      int: mon.abilities?.int || mon.int,
      wis: mon.abilities?.wis || mon.wis,
      cha: mon.abilities?.cha || mon.cha,
      // Skills and saves (already correct format)
      skill: mon.skill || mon.skills,
      save: mon.save || mon.saves || mon.savingThrows,
      // Senses
      passive: mon.passive || mon.pp,
      senses: sensesValue,
      languages:
        mon.languages ||
        (mon.lang
          ? Array.isArray(mon.lang)
            ? mon.lang.join(", ")
            : mon.lang
          : ""),
      // Speed (make sure it's a string or number, not an object)
      speed: speedValue || (mon.spd ? `${mon.spd} ft.` : "30 ft."),
      fly: flySpeed,
      swim: swimSpeed,
      climb: climbSpeed,
      burrow: burrowSpeed,
      // Defenses - convert arrays to strings with special formatting
      // Support both expanded format (damageImmunities) and compact format (immune)
      vulnerabilities: parseDefenseArray(mon.damageVulnerabilities || mon.vulnerable),
      resistances: parseDefenseArray(mon.damageResistances || mon.resist || mon.res),
      immunities: parseDefenseArray(mon.damageImmunities || mon.immune),
      conditionImmunities: parseDefenseArray(mon.conditionImmunities || mon.conditionImmune || mon.condImm),
      // Keep original fields for runtime parsing in UI
      damageVulnerabilities: mon.damageVulnerabilities,
      vulnerable: mon.vulnerable,
      damageResistances: mon.damageResistances,
      resist: mon.resist,
      res: mon.res,
      damageImmunities: mon.damageImmunities,
      immune: mon.immune,
      conditionImmune: mon.conditionImmune,
      condImm: mon.condImm,
      // Traits, Actions, etc. (keep as arrays for proper rendering)
      traits: mon.traits || mon.trait,
      actions: mon.actions || mon.action,
      bonusActions: mon.bonus,
      reactions: mon.reaction,
      legendary: mon.legendary,
      legendaryActions: mon.legendaryActions,
      legendaryGroup: mon.legendaryGroup,
      // Spellcasting
      spellcasting: mon.spellcasting,
      // Token and image URLs
      // Generate token URL via server proxy if not provided
      tokenUrl: mon.meta?.tokenUrl || mon.tokenUrl || (mon.name && mon.source ?
        `${API_URL('')}/api/token/${encodeURIComponent(mon.source)}/${encodeURIComponent(mon.name)}` : null),
      imageUrl: mon.meta?.imageUrl || mon.imageUrl || (mon.name && mon.source ?
        `${API_URL('')}/api/token/${encodeURIComponent(mon.source)}/${encodeURIComponent(mon.name)}` : null),
    };

    const next = { ...enc, combatants: { ...enc.combatants, [id]: c } };

    // If initiative has already been rolled, add the new combatant to the initiative order
    if (next.initiativeOrder && next.initiativeOrder.length > 0) {
      // Insert the new combatant into the initiative order at the correct position
      // based on its initiative (which is 0 initially, so it goes at the end)
      const newInitiativeOrder = [...next.initiativeOrder];

      // Find the correct position based on initiative and tie-breaker
      let insertIndex = newInitiativeOrder.length;
      for (let i = 0; i < newInitiativeOrder.length; i++) {
        const orderId = newInitiativeOrder[i];
        let otherCombatant;

        if (typeof orderId === 'object' && orderId.type === 'lair') {
          // Lair action marker
          otherCombatant = { initiative: orderId.initiative, initiativeTieBreaker: 0 };
        } else {
          // Regular combatant
          otherCombatant = next.combatants[orderId];
        }

        if (otherCombatant) {
          const otherInit = otherCombatant.initiative ?? 0;
          const otherTie = otherCombatant.initiativeTieBreaker ?? 0;
          const newInit = c.initiative ?? 0;
          const newTie = c.initiativeTieBreaker ?? 0;

          // If the new combatant has higher initiative (or same with higher tie-breaker), insert before
          if (newInit > otherInit || (newInit === otherInit && newTie > otherTie)) {
            insertIndex = i;
            break;
          }
        }
      }

      newInitiativeOrder.splice(insertIndex, 0, id);
      next.initiativeOrder = newInitiativeOrder;
    }

    save(next);
  }

  async function addCustom() {
    const name = await prompt("Name des Combatants?", "Neuer Combatant");
    if (!name) return; // User cancelled

    const id = crypto.randomUUID();
    const c = {
      id,
      name,
      ac: 10,
      baseHP: 10,
      hp: 10,
      tempHP: 0,
      initiativeMod: 0,
      initiative: 0,
      initiativeTieBreaker: 0,
      player: true,
      notes: "",
      concentration: false,
      concentrationMod: 0,
      spellSlots: {},
      deathSaves: { successes: 0, failures: 0 },
      legendaryPoints: 0,
      legendaryPointsMax: 0,
      reactionUsed: false,
    };
    const next = { ...enc, combatants: { ...enc.combatants, [id]: c } };

    // If initiative has already been rolled, add the new combatant to the initiative order
    if (next.initiativeOrder && next.initiativeOrder.length > 0) {
      const newInitiativeOrder = [...next.initiativeOrder];
      let insertIndex = newInitiativeOrder.length;
      for (let i = 0; i < newInitiativeOrder.length; i++) {
        const orderId = newInitiativeOrder[i];
        let otherCombatant;
        if (typeof orderId === 'object' && orderId.type === 'lair') {
          otherCombatant = { initiative: orderId.initiative, initiativeTieBreaker: 0 };
        } else {
          otherCombatant = next.combatants[orderId];
        }
        if (otherCombatant) {
          const otherInit = otherCombatant.initiative ?? 0;
          const otherTie = otherCombatant.initiativeTieBreaker ?? 0;
          const newInit = c.initiative ?? 0;
          const newTie = c.initiativeTieBreaker ?? 0;
          if (newInit > otherInit || (newInit === otherInit && newTie > otherTie)) {
            insertIndex = i;
            break;
          }
        }
      }
      newInitiativeOrder.splice(insertIndex, 0, id);
      next.initiativeOrder = newInitiativeOrder;
    }

    save(next);
  }

  function rollDeathSave(id) {
    const roll = rollD20();
    const c = enc.combatants[id];
    const deathSaves = { ...c.deathSaves };

    if (roll === 20) {
      // Nat 20: regain 1 HP
      updateCombatant(id, { hp: 1, deathSaves: { successes: 0, failures: 0 } });
      setDiceRollResult({
        type: "deathSave",
        name: c.name,
        roll,
        total: roll,
        passed: true,
        critical: true,
      });
    } else if (roll === 1) {
      // Nat 1: two failures
      deathSaves.failures = Math.min(3, deathSaves.failures + 2);
      updateCombatant(id, { deathSaves });
      setDiceRollResult({
        type: "deathSave",
        name: c.name,
        roll,
        total: roll,
        passed: false,
        critical: true,
      });
    } else if (roll >= 10) {
      // Success
      deathSaves.successes++;
      if (deathSaves.successes >= 3) {
        // Stabilized
        deathSaves.successes = 0;
        deathSaves.failures = 0;
      }
      updateCombatant(id, { deathSaves });
      setDiceRollResult({
        type: "deathSave",
        name: c.name,
        roll,
        total: roll,
        passed: true,
      });
    } else {
      // Failure
      deathSaves.failures++;
      updateCombatant(id, { deathSaves });
      setDiceRollResult({
        type: "deathSave",
        name: c.name,
        roll,
        total: roll,
        passed: false,
      });
    }
  }

  function nextTurn() {
    const count = Object.keys(enc?.combatants || {}).length;
    if (!count || !enc) return;
    let { round, turnIndex } = enc;
    turnIndex = (turnIndex + 1) % count;
    const isNewRound = turnIndex === 0;
    if (isNewRound) round += 1;

    // Reset legendary points at the top of each round (initiative count 20)
    let updatedCombatants = { ...enc.combatants };
    if (isNewRound) {
      Object.keys(updatedCombatants).forEach(id => {
        const combatant = updatedCombatants[id];
        if (combatant.legendaryPointsMax > 0) {
          updatedCombatants[id] = {
            ...combatant,
            legendaryPoints: combatant.legendaryPointsMax,
          };
        }
      });
    }

    // Get the combatant who is now active
    const nextCombatantId = enc.initiativeOrder[turnIndex];
    const nextCombatant = updatedCombatants[nextCombatantId];

    // Reset reaction for the creature whose turn it is
    if (nextCombatant && !nextCombatant.isLairAction) {
      updatedCombatants[nextCombatantId] = {
        ...nextCombatant,
        reactionUsed: false
      };
    }

    // Check for recharge abilities that need to be rolled
    if (
      nextCombatant &&
      nextCombatant.actions &&
      Array.isArray(nextCombatant.actions)
    ) {
      const rechargeRolls = [];

      nextCombatant.actions.forEach((action, idx) => {
        const actionName = action.n || action.name || "";
        const desc =
          action.d || action.desc || action.description || action.text || "";

        // Check for recharge - both formats: "{@recharge 5}" and "(Recharge 5-6)"
        const rechargeMatch =
          actionName.match(/\{@recharge (\d+)\}/i) ||
          actionName.match(/\(Recharge (\d+)(?:-6)?\)/i) ||
          desc.match(/Recharge (\d+)(?:-6)?/i);
        const rechargeTrigger = rechargeMatch
          ? parseInt(rechargeMatch[1])
          : null;

        if (rechargeTrigger) {
          const rechargeKey = `action_${idx}`;
          const recharges = nextCombatant.recharges || {};
          const isCharged = recharges[rechargeKey] !== false; // Default to charged

          // If not charged, queue for rolling (don't roll yet - let dice roller do it)
          if (!isCharged) {
            rechargeRolls.push({
              actionName: actionName.replace(/\{@recharge \d+\}/i, "").trim(),
              rechargeTrigger,
              combatantId: nextCombatantId,
              rechargeKey,
              recharges,
            });
          }
        }
      });

      // Show recharge results if any - with dice animation
      if (rechargeRolls.length > 0) {
        setTimeout(() => {
          rechargeRolls.forEach((rechargeInfo, i) => {
            setTimeout(() => {
              // Store recharge context (WITHOUT pre-rolled result - dice roller will roll it)
              window._pendingAutoRecharge = {
                actionName: rechargeInfo.actionName,
                combatantName: nextCombatant.name,
                rechargeTrigger: rechargeInfo.rechargeTrigger,
                combatantId: rechargeInfo.combatantId,
                rechargeKey: rechargeInfo.rechargeKey,
                recharges: rechargeInfo.recharges,
              };

              // Open dice roller with auto-roll
              setDiceRollerInitialNotation("1d6");
              setDiceRollerAutoRoll(true);
              setShowDiceRoller(true);
            }, i * 2500); // Stagger by 2.5 seconds to allow animation time + result display
          });
        }, 300); // Small delay to let the turn change render first
      }
    }

    save({ ...enc, combatants: updatedCombatants, round, turnIndex });
  }

  function prevTurn() {
    const count = Object.keys(enc?.combatants || {}).length;
    if (!count || !enc) return;
    let { round, turnIndex } = enc;
    turnIndex = (turnIndex - 1 + count) % count;
    if (turnIndex === count - 1) round = Math.max(1, round - 1);
    save({ ...enc, round, turnIndex });
  }

  // Function to load spell details
  async function loadSpellDetails(spellName) {
    try {
      // Clean up spell name from {@spell Name} format
      const cleanName = spellName
        .replace(/\{@spell ([^}|]+)(?:\|[^}]+)?\}/gi, "$1")
        .trim();

      const response = await apiGet(
        `/api/spells/${encodeURIComponent(cleanName)}`
      );
      const spell = await response.json();
      setSelectedSpell(spell);
      setShowSpellModal(true);
    } catch (error) {
      console.error("Error loading spell:", error);
      await alert(`Spell "${spellName}" nicht gefunden`);
    }
  }

  // Component to render text with clickable spell names
  function ClickableSpellText({ text }) {
    if (!text) return null;

    const parts = [];
    let lastIndex = 0;

    // Pattern 1: {@spell Name|Source} or {@spell Name}
    const markupPattern = /\{@spell ([^}|]+)(?:\|([^}]+))?\}/g;

    // Pattern 2: "Spell Name|SOURCE" (capitalized spell followed by |UPPERCASE)
    // This catches things like "Misty Step|XPHB" or "Counterspell|XPHB or Shield|XPHB"
    const plainPattern = /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\|([A-Z]+)\b/g;

    // Combine both patterns
    const combinedPattern = new RegExp(
      `(${markupPattern.source})|(${plainPattern.source})`,
      "g"
    );

    // Simpler approach: find both patterns separately
    const matches = [];

    // Find markup patterns
    let match;
    while ((match = markupPattern.exec(text)) !== null) {
      matches.push({
        index: match.index,
        length: match[0].length,
        spellName: match[1],
      });
    }

    // Reset and find plain patterns
    while ((match = plainPattern.exec(text)) !== null) {
      // Check if this isn't already captured by markup pattern
      const overlaps = matches.some(
        (m) => match.index >= m.index && match.index < m.index + m.length
      );
      if (!overlaps) {
        matches.push({
          index: match.index,
          length: match[0].length,
          spellName: match[1], // First capture group is the spell name without |SOURCE
        });
      }
    }

    // Sort matches by index
    matches.sort((a, b) => a.index - b.index);

    // Build parts array
    matches.forEach((match) => {
      // Add text before this match
      if (match.index > lastIndex) {
        parts.push({
          type: "text",
          content: text.slice(lastIndex, match.index),
        });
      }

      // Add the spell
      parts.push({ type: "spell", content: match.spellName });

      lastIndex = match.index + match.length;
    });

    // Add remaining text
    if (lastIndex < text.length) {
      parts.push({ type: "text", content: text.slice(lastIndex) });
    }

    // If no spells found, just return text
    if (parts.length === 0) {
      return <span>{text}</span>;
    }

    return (
      <>
        {parts.map((part, idx) => {
          if (part.type === "spell") {
            return (
              <span
                key={idx}
                className="underline decoration-purple-500 dark:decoration-purple-400 decoration-2 underline-offset-2 text-purple-700 dark:text-purple-300 cursor-pointer hover:text-purple-900 dark:hover:text-purple-100 font-medium"
                onMouseEnter={async (e) => {
                  try {
                    const response = await apiGet(
                      `/api/spells/${encodeURIComponent(part.content)}`
                    );
                    const spell = await response.json();

                    // Position tooltip to the left of cursor
                    // If mouse is in lower half of screen, position above cursor, otherwise below
                    const tooltipWidth = 634; // 384px + 50px = 434px
                    const x = e.clientX - tooltipWidth - 15;
                    const y =
                      e.clientY > window.innerHeight / 2
                        ? e.clientY - 200 // Upper position if in lower half
                        : e.clientY + 15; // Lower position if in upper half

                    setSpellTooltip({ spell, x, y });
                  } catch (error) {
                    console.error("Error loading spell:", error);
                  }
                }}
                onMouseMove={(e) => {
                  if (spellTooltip.spell) {
                    const tooltipWidth = 634;
                    const x = e.clientX - tooltipWidth - 15;
                    const y =
                      e.clientY > window.innerHeight / 2
                        ? e.clientY - 200
                        : e.clientY + 15;
                    setSpellTooltip((prev) => ({ ...prev, x, y }));
                  }
                }}
                onMouseLeave={() => {
                  setSpellTooltip({ spell: null, x: 0, y: 0 });
                }}
              >
                {part.content}
              </span>
            );
          }
          return <span key={idx}>{part.content}</span>;
        })}
      </>
    );
  }

  // Component to render text with clickable dice notation (but NOT attack rolls as those are handled separately)
  function RollableText({
    text,
    skipAttackRolls = true,
    removeAttackText = false,
    character = '',
    actionName = '',
    onRoll = null,
  }) {
    if (!text) return null;

    // First, clean up 5e.tools markup tags like {@h}, {@atk mw}, {@damage 2d6}, etc.
    // Special handling for {@damage XdY} - extract the dice notation
    let cleanText = text.replace(/\{@damage ([^}]+)\}/g, "$1");
    // Special handling for {@dice XdY} - extract the dice notation
    cleanText = cleanText.replace(/\{@dice ([^}]+)\}/g, "$1");
    // Special handling for {@dc N} - extract the DC number
    cleanText = cleanText.replace(/\{@dc (\d+)\}/g, "DC $1");
    // Special handling for {@condition NAME} - extract the condition name
    cleanText = cleanText.replace(/\{@condition ([^}|]+)(?:\|[^}]+)?\}/g, "$1");
    // Special handling for {@creature NAME} - extract the creature name
    cleanText = cleanText.replace(/\{@creature ([^}|]+)(?:\|\|[^}|]+)?(?:\|[^}]+)?\}/g, "$1");
    // Special handling for {@quickref ...} - extract the reference name
    cleanText = cleanText.replace(/\{@quickref ([^}|]+)\|[^}]+\}/g, "$1");
    // Remove other tags entirely
    cleanText = cleanText.replace(/\{@[^}]+\}/g, "");

    // If removeAttackText is true, remove "to hit" attack patterns and damage descriptions
    // to avoid duplication when they're already shown as buttons
    if (removeAttackText) {
      // Remove patterns like "mw +7 to hit, reach 5 ft., one target."
      cleanText = cleanText.replace(
        /(?:mw|ms|rw|rs|Melee Weapon Attack|Melee Spell Attack|Ranged Weapon Attack|Ranged Spell Attack):?\s*[+-]?\d+\s*to hit[^.]*\.\s*/gi,
        ""
      );
      // Remove patterns like "Hit: 9 (2d6 + 2) slashing damage"
      cleanText = cleanText.replace(
        /(?:Hit|{@h}):\s*\d+\s*\([^)]+\)\s*\w+\s*damage[^.]*\.\s*/gi,
        ""
      );
      // Clean up any leading/trailing whitespace or commas
      cleanText = cleanText.trim().replace(/^[,.\s]+|[,.\s]+$/g, "");
    }

    // Match dice notation (XdY, XdY+Z, XdY-Z) with optional spaces around operators
    const dicePattern = /(\d+d\d+(?:\s*[+-]\s*\d+)?)/gi;
    const parts = cleanText.split(dicePattern).filter((p) => p); // Remove empty strings

    return (
      <>
        {parts.map((part, idx) => {
          // Check if it's dice notation (XdY)
          if (part.match(dicePattern)) {
            // Normalize notation by removing spaces for the roller
            const normalizedNotation = part.replace(/\s+/g, "");

            // Determine if this is a d20 roll (for advantage/disadvantage) or damage roll (for crit)
            const isD20 = normalizedNotation.match(/\d*d20/i);

            return (
              <button
                key={idx}
                className="inline-flex items-center gap-1 px-1.5 py-0.5 bg-blue-100 dark:bg-blue-900/40 hover:bg-blue-200 dark:hover:bg-blue-800/60 text-blue-800 dark:text-blue-300 rounded font-mono text-xs font-semibold transition-colors cursor-pointer border border-blue-300 dark:border-blue-700"
                onClick={() => {
                  // Left click: Roll immediately using universal function
                  let label = actionName ? `${character} - ${actionName}` : (character || '');
                  if (!isD20 && label) label += ' - Damage';
                  rollDice({
                    notation: normalizedNotation,
                    rollMode: "normal",
                    label: label || undefined,
                    character: character || undefined,
                  });
                  // Call onRoll callback if provided
                  if (onRoll) onRoll();
                }}
                onContextMenu={(e) => {
                  // Right click: Show context menu
                  e.preventDefault();
                  e.stopPropagation();
                  let label = actionName ? `${character} - ${actionName}` : (character || '');
                  if (!isD20 && label) label += ' - Damage';
                  setDiceContextMenu({
                    show: true,
                    x: e.clientX,
                    y: e.clientY,
                    notation: normalizedNotation,
                    type: isD20 ? "d20" : "damage",
                    label: label || undefined,
                    onRoll: onRoll,
                  });
                }}
                title={
                  isD20
                    ? "Left: Roll | Right: Adv/Dis"
                    : "Left: Roll | Right: Crit"
                }
              >
                ðŸŽ² {part}
              </button>
            );
          }

          return <span key={idx}>{part}</span>;
        })}
      </>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800 text-slate-900 dark:text-slate-100 transition-colors">
      <header className="sticky top-0 z-40 border-b border-slate-200 dark:border-slate-700 bg-white/80 dark:bg-slate-900/80 backdrop-blur-lg shadow-sm">
        <div className="max-w-7xl mx-auto px-4 py-3 flex items-center gap-3">
          <h1 className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent">
            Encounter++
          </h1>

          {/* Mode Toggle - Always visible */}
          {enc && (
            <div className="flex items-center gap-1 bg-gradient-to-r from-orange-50 to-red-50 dark:from-orange-900/20 dark:to-red-900/20 border border-orange-200 dark:border-orange-800 rounded-lg p-1">
              <button
                className={`py-1.5 px-3 rounded-md font-medium text-sm transition-all ${
                  !combatMode
                    ? "bg-white dark:bg-slate-700 shadow text-orange-700 dark:text-orange-300"
                    : "text-slate-600 dark:text-slate-400 hover:bg-white/50 dark:hover:bg-slate-700/50"
                }`}
                onClick={() => setCombatMode(false)}
              >
                ðŸ“ Prep
              </button>
              <button
                className={`py-1.5 px-3 rounded-md font-medium text-sm transition-all ${
                  combatMode
                    ? "bg-white dark:bg-slate-700 shadow text-red-700 dark:text-red-300"
                    : "text-slate-600 dark:text-slate-400 hover:bg-white/50 dark:hover:bg-slate-700/50"
                }`}
                onClick={() => setCombatMode(true)}
              >
                âš”ï¸ Combat
              </button>
            </div>
          )}

          <div className="ml-auto flex items-center gap-2">
            <button
              className="btn w-10 h-10 p-0 flex items-center justify-center"
              onClick={() => setDarkMode(!darkMode)}
              title={darkMode ? "Switch to Light Mode" : "Switch to Dark Mode"}
            >
              {darkMode ? "â˜€ï¸" : "ðŸŒ™"}
            </button>
            <button
              className="btn bg-purple-600 text-white hover:bg-purple-700 border-purple-600"
              onClick={() => setShowCampaignManager(true)}
              title="Kampagnen verwalten"
            >
              ðŸ“š Kampagnen
            </button>
            <button
              className="btn bg-blue-500 text-white hover:bg-blue-600 border-blue-500"
              onClick={createEncounter}
            >
              + New Encounter
            </button>
            <label className="btn cursor-pointer">
              ðŸ“¥ Import
              <input
                type="file"
                accept="application/json"
                className="hidden"
                onChange={(e) =>
                  e.target.files?.[0] && importEncounter(e.target.files[0])
                }
              />
            </label>

            {/* Profile Menu */}
            <div className="relative profile-menu-container">
              <button
                className="w-10 h-10 rounded-full bg-gradient-to-br from-purple-500 to-blue-500 text-white font-semibold flex items-center justify-center hover:from-purple-600 hover:to-blue-600 transition-all shadow-md hover:shadow-lg"
                onClick={() => setShowProfileMenu(!showProfileMenu)}
                title={user.email}
              >
                {user.email
                  .match(/[a-zA-Z]/g)
                  ?.slice(0, 2)
                  .join("")
                  .toUpperCase() || "US"}
              </button>

              {showProfileMenu && (
                <div className="absolute right-0 mt-2 w-64 bg-white dark:bg-slate-800 rounded-lg shadow-xl border border-slate-200 dark:border-slate-700 py-2 z-40">
                  <div className="px-4 py-3 border-b border-slate-200 dark:border-slate-700">
                    <div className="text-sm font-medium text-slate-900 dark:text-slate-100">
                      Angemeldet als
                    </div>
                    <div className="text-sm text-slate-600 dark:text-slate-400 truncate">
                      {user.email}
                    </div>
                  </div>
                  <button
                    className="w-full text-left px-4 py-2 text-sm text-slate-700 dark:text-slate-300 hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors flex items-center gap-2"
                    onClick={() => {
                      setShowProfileMenu(false);
                      setShowSettings(true);
                    }}
                  >
                    <span>âš™ï¸</span>
                    <span>Einstellungen</span>
                  </button>
                  <button
                    className="w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors flex items-center gap-2"
                    onClick={() => {
                      setShowProfileMenu(false);
                      logout();
                    }}
                  >
                    <span>ðŸšª</span>
                    <span>Logout</span>
                  </button>
                </div>
              )}
            </div>
          </div>
        </div>
      </header>

      <main
        className="mx-auto p-6 grid gap-6"
        style={{
          maxWidth: '100%',
          gridTemplateColumns: sidebarVisible
            ? "minmax(250px, 1fr) minmax(0, 2fr)"  // Sidebar visible: 2 columns
            : "64px minmax(0, 1fr)",  // Sidebar collapsed: mini sidebar + content
          transition: 'grid-template-columns 700ms ease-in-out'
        }}
      >
        {/* Left Column - Sidebar (Full or Mini) */}
        <aside className="space-y-4 transition-all duration-700 ease-in-out relative">
          {/* Sidebar Toggle Button */}
          <button
            className={`h-12 rounded-xl bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white shadow-lg hover:shadow-xl flex items-center justify-center transition-all duration-700 sticky top-20 z-20 group relative overflow-hidden ${
              sidebarVisible ? 'w-full' : 'w-14'
            }`}
            onClick={() => {
              setSidebarVisible(!sidebarVisible);
              if (!sidebarVisible) setActiveSidebarPanel(null);
            }}
            title={sidebarVisible ? "Sidebar ausblenden" : "Sidebar einblenden"}
          >
            {/* Animated background gradient on hover */}
            <div className="absolute inset-0 bg-gradient-to-r from-indigo-600 to-blue-700 opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>

            {/* Icon and Text */}
            <div className="relative flex items-center gap-2">
              {/* Custom Sidebar Icons */}
              <img
                src={sidebarVisible ? "/icons8-sidebar-50.png" : "/icons8-sidebar-50-2.png"}
                alt={sidebarVisible ? "Hide sidebar" : "Show sidebar"}
                className="w-5 h-5 transition-opacity duration-700 filter brightness-0 invert"
              />
              {sidebarVisible && (
                <span className="text-sm font-semibold tracking-wide transition-opacity duration-300 opacity-0 group-hover:opacity-100">
                  Hide
                </span>
              )}
            </div>
          </button>

          {/* Full Sidebar Content - fades and scales */}
          <div className={`transition-all duration-700 ease-in-out origin-left space-y-4 ${
            sidebarVisible
              ? 'opacity-100 scale-100 max-h-[9999px]'
              : 'opacity-0 scale-75 pointer-events-none max-h-0 overflow-hidden'
          }`}>
              <section className={`card flex flex-col overflow-hidden transition-all duration-300 ${encounterTreeCollapsed ? 'h-12' : (combatMode ? 'h-[600px]' : 'h-[calc(100vh-180px)]')}`}>
                <div className="flex items-center justify-between mb-2 flex-shrink-0">
                  <h2 className="text-lg font-bold">ðŸ“ Encounters</h2>
                  <button
                    onClick={() => setEncounterTreeCollapsed(!encounterTreeCollapsed)}
                    className="w-8 h-8 flex items-center justify-center rounded hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
                    title={encounterTreeCollapsed ? "Ausklappen" : "Einklappen"}
                  >
                    {encounterTreeCollapsed ? 'â–¼' : 'â–²'}
                  </button>
                </div>
                {!encounterTreeCollapsed && (
                  <div className="flex-1 overflow-hidden">
                    <EncounterTreeView
                      encounters={encounters}
                      loading={encountersLoading}
                      currentId={currentId}
                      onSelectEncounter={setCurrentId}
                      onDeleteEncounter={deleteEncounter}
                      onCreateEncounter={createEncounter}
                      campaigns={campaigns}
                      onRefreshEncounters={async () => {
                        setEncountersLoading(true);
                        try {
                          const r = await apiGet("/api/encounters");
                          setEncounters(await r.json());
                        } catch (err) {
                          console.error('Failed to refresh encounters:', err);
                        } finally {
                          setEncountersLoading(false);
                        }
                      }}
                      onMoveEncounter={(encounterId, folderPath) => {
                        setEncounters(prev => prev.map(e =>
                          e.id === encounterId ? { ...e, folder: folderPath } : e
                        ));
                      }}
                    />
                  </div>
                )}
              </section>

              {/* Combat Mode Quick Actions */}
              {combatMode && enc && (
                <div className={`card bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 transition-all duration-300 ${quickActionsCollapsed ? 'pb-0' : ''}`}>
                  <div className="flex items-center justify-between mb-2">
                    <h2 className="text-sm font-bold text-red-900 dark:text-red-300">
                      âš”ï¸ Quick Actions
                    </h2>
                    <button
                      onClick={() => setQuickActionsCollapsed(!quickActionsCollapsed)}
                      className="w-8 h-8 flex items-center justify-center rounded hover:bg-red-200 dark:hover:bg-red-800 transition-colors"
                      title={quickActionsCollapsed ? "Ausklappen" : "Einklappen"}
                    >
                      {quickActionsCollapsed ? 'â–¼' : 'â–²'}
                    </button>
                  </div>
                  {!quickActionsCollapsed && (
                    <div className="space-y-2">
                      <button
                        className="btn w-full bg-red-600 text-white hover:bg-red-700 border-red-600 text-sm py-1"
                        onClick={rollInitiativeForAll}
                      >
                        ðŸŽ² Roll Initiative
                      </button>
                      <button
                        className="btn w-full bg-yellow-600 text-white hover:bg-yellow-700 border-yellow-600 text-sm py-1"
                        onClick={resetCombat}
                      >
                        ðŸ”„ Reset Combat
                      </button>
                      <button
                        className="btn w-full bg-orange-500 text-white hover:bg-orange-600 border-orange-500 text-sm py-1"
                        onClick={addCustom}
                      >
                        âž• Add Custom
                      </button>
                    </div>
                  )}
                </div>
              )}

              {/* Combat Mode - Compact Monster Browser */}
              {combatMode && (
                <div className={`card bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 flex flex-col overflow-hidden transition-all duration-300 ${monsterBrowserCollapsed ? 'h-12' : 'max-h-[300px]'}`}>
                  <div className="flex items-center justify-between mb-2 flex-shrink-0">
                    <h2 className="text-sm font-bold text-red-900 dark:text-red-300">
                      ðŸ‰ Quick Add Monsters
                    </h2>
                    <button
                      onClick={() => setMonsterBrowserCollapsed(!monsterBrowserCollapsed)}
                      className="w-8 h-8 flex items-center justify-center rounded hover:bg-red-200 dark:hover:bg-red-800 transition-colors"
                      title={monsterBrowserCollapsed ? "Ausklappen" : "Einklappen"}
                    >
                      {monsterBrowserCollapsed ? 'â–¼' : 'â–²'}
                    </button>
                  </div>
                  {!monsterBrowserCollapsed && (
                    <div className="flex-1 overflow-hidden flex flex-col">
                      <MonsterBrowser
                        onPick={addMonster}
                        onEdit={(monster) => {
                          setEditingCreature(monster);
                          setShowCreatureManager(true);
                        }}
                        RollableText={RollableText}
                        combatMode={combatMode}
                        selectedCombatant={selectedCombatant}
                      />
                    </div>
                  )}
                </div>
              )}
          </div>

          {/* Mini Icon Mode - fades in when sidebar collapsed */}
          <div className={`transition-all duration-700 ease-in-out space-y-2 ${
            !sidebarVisible
              ? 'opacity-100 scale-100 max-h-[9999px]'
              : 'opacity-0 scale-0 pointer-events-none max-h-0 overflow-hidden'
          }`}>
              <div className="flex flex-col gap-2">
                {/* Encounters Icon */}
                <button
                  className={`w-14 h-14 rounded-lg flex items-center justify-center text-2xl transition-all ${
                    activeSidebarPanel === 'encounters'
                      ? 'bg-blue-500 text-white shadow-lg'
                      : 'bg-white dark:bg-slate-800 hover:bg-blue-50 dark:hover:bg-slate-700 border border-slate-200 dark:border-slate-700'
                  }`}
                  onClick={() => setActiveSidebarPanel(activeSidebarPanel === 'encounters' ? null : 'encounters')}
                  title="Encounters"
                >
                  ðŸ“
                </button>

                {/* Quick Actions Icon (Combat Mode Only) */}
                {combatMode && enc && (
                  <button
                    className={`w-14 h-14 rounded-lg flex items-center justify-center text-2xl transition-all ${
                      activeSidebarPanel === 'quickActions'
                        ? 'bg-red-500 text-white shadow-lg'
                        : 'bg-white dark:bg-slate-800 hover:bg-red-50 dark:hover:bg-slate-700 border border-slate-200 dark:border-slate-700'
                    }`}
                    onClick={() => setActiveSidebarPanel(activeSidebarPanel === 'quickActions' ? null : 'quickActions')}
                    title="Quick Actions"
                  >
                    âš”ï¸
                  </button>
                )}

                {/* Monster Browser Icon (Combat Mode Only) */}
                {combatMode && (
                  <button
                    className={`w-14 h-14 rounded-lg flex items-center justify-center text-2xl transition-all ${
                      activeSidebarPanel === 'monsters'
                        ? 'bg-green-500 text-white shadow-lg'
                        : 'bg-white dark:bg-slate-800 hover:bg-green-50 dark:hover:bg-slate-700 border border-slate-200 dark:border-slate-700'
                    }`}
                    onClick={() => setActiveSidebarPanel(activeSidebarPanel === 'monsters' ? null : 'monsters')}
                    title="Quick Add Monsters"
                  >
                    ðŸ‰
                  </button>
                )}

                {/* Player Characters Icon (Combat Mode Only) */}
                {combatMode && enc && (
                  <button
                    className={`w-14 h-14 rounded-lg flex items-center justify-center text-2xl transition-all ${
                      activeSidebarPanel === 'players'
                        ? 'bg-purple-500 text-white shadow-lg'
                        : 'bg-white dark:bg-slate-800 hover:bg-purple-50 dark:hover:bg-slate-700 border border-slate-200 dark:border-slate-700'
                    }`}
                    onClick={() => setActiveSidebarPanel(activeSidebarPanel === 'players' ? null : 'players')}
                    title="Player Characters"
                  >
                    ðŸ‘¥
                  </button>
                )}
              </div>
          </div>
        </aside>

        {/* Floating Sidebar Panels (Mini Mode Only) */}
        {!sidebarVisible && activeSidebarPanel && (
          <>
            {/* Backdrop */}
            <div
              className="fixed inset-0 bg-black/20 z-30 transition-opacity duration-300"
              onClick={() => setActiveSidebarPanel(null)}
            ></div>

            {/* Encounters Panel */}
            {activeSidebarPanel === 'encounters' && (
              <div className="fixed left-20 top-24 w-80 max-h-[calc(100vh-120px)] bg-white dark:bg-slate-800 rounded-xl shadow-2xl border border-slate-200 dark:border-slate-700 z-40 flex flex-col overflow-hidden transition-all duration-300 ease-out">
                <div className="flex items-center justify-between p-4 border-b border-slate-200 dark:border-slate-700">
                  <h2 className="text-lg font-bold">ðŸ“ Encounters</h2>
                  <button
                    onClick={() => setActiveSidebarPanel(null)}
                    className="w-8 h-8 flex items-center justify-center rounded hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
                  >
                    âœ•
                  </button>
                </div>
                <div className="flex-1 overflow-hidden p-4">
                  <EncounterTreeView
                    encounters={encounters}
                    loading={encountersLoading}
                    currentId={currentId}
                    onSelectEncounter={(id) => {
                      setCurrentId(id);
                      setActiveSidebarPanel(null);
                    }}
                    onDeleteEncounter={deleteEncounter}
                    onCreateEncounter={createEncounter}
                    campaigns={campaigns}
                    onRefreshEncounters={async () => {
                      setEncountersLoading(true);
                      try {
                        const r = await apiGet("/api/encounters");
                        setEncounters(await r.json());
                      } catch (err) {
                        console.error('Failed to refresh encounters:', err);
                      } finally {
                        setEncountersLoading(false);
                      }
                    }}
                    onMoveEncounter={(encounterId, folderPath) => {
                      setEncounters(prev => prev.map(e =>
                        e.id === encounterId ? { ...e, folder: folderPath } : e
                      ));
                    }}
                  />
                </div>
              </div>
            )}

            {/* Quick Actions Panel */}
            {activeSidebarPanel === 'quickActions' && (
              <div className="fixed left-20 top-24 w-64 bg-white dark:bg-slate-800 rounded-xl shadow-2xl border border-slate-200 dark:border-slate-700 z-40 p-4 transition-all duration-300 ease-out">
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-bold text-red-900 dark:text-red-300">âš”ï¸ Quick Actions</h2>
                  <button
                    onClick={() => setActiveSidebarPanel(null)}
                    className="w-8 h-8 flex items-center justify-center rounded hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
                  >
                    âœ•
                  </button>
                </div>
                <div className="space-y-2">
                  <button
                    className="btn w-full bg-red-600 text-white hover:bg-red-700 border-red-600"
                    onClick={() => {
                      rollInitiativeForAll();
                      setActiveSidebarPanel(null);
                    }}
                  >
                    ðŸŽ² Roll Initiative
                  </button>
                  <button
                    className="btn w-full bg-yellow-600 text-white hover:bg-yellow-700 border-yellow-600"
                    onClick={() => {
                      resetCombat();
                      setActiveSidebarPanel(null);
                    }}
                  >
                    ðŸ”„ Reset Combat
                  </button>
                  <button
                    className="btn w-full bg-orange-500 text-white hover:bg-orange-600 border-orange-500"
                    onClick={() => {
                      addCustom();
                      setActiveSidebarPanel(null);
                    }}
                  >
                    âž• Add Custom
                  </button>
                </div>
              </div>
            )}

            {/* Monster Browser Panel */}
            {activeSidebarPanel === 'monsters' && (
              <div className="fixed left-20 top-24 w-96 max-h-[calc(100vh-120px)] bg-white dark:bg-slate-800 rounded-xl shadow-2xl border border-slate-200 dark:border-slate-700 z-40 flex flex-col overflow-hidden transition-all duration-300 ease-out">
                <div className="flex items-center justify-between p-4 border-b border-slate-200 dark:border-slate-700">
                  <h2 className="text-lg font-bold text-green-900 dark:text-green-300">ðŸ‰ Quick Add Monsters</h2>
                  <button
                    onClick={() => setActiveSidebarPanel(null)}
                    className="w-8 h-8 flex items-center justify-center rounded hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
                  >
                    âœ•
                  </button>
                </div>
                <div className="flex-1 overflow-hidden p-4">
                  <MonsterBrowser
                    onPick={(mon) => {
                      addMonster(mon);
                      setActiveSidebarPanel(null);
                    }}
                    onEdit={(monster) => {
                      setEditingCreature(monster);
                      setShowCreatureManager(true);
                      setActiveSidebarPanel(null);
                    }}
                    RollableText={RollableText}
                    combatMode={combatMode}
                    selectedCombatant={selectedCombatant}
                  />
                </div>
              </div>
            )}

            {/* Player Characters Panel */}
            {activeSidebarPanel === 'players' && (
              <div className="fixed left-20 top-24 w-96 max-h-[calc(100vh-120px)] bg-white dark:bg-slate-800 rounded-xl shadow-2xl border border-slate-200 dark:border-slate-700 z-40 flex flex-col overflow-hidden transition-all duration-300 ease-out">
                <div className="flex items-center justify-between p-4 border-b border-slate-200 dark:border-slate-700">
                  <h2 className="text-lg font-bold text-purple-900 dark:text-purple-300">ðŸ‘¥ Player Characters</h2>
                  <button
                    onClick={() => setActiveSidebarPanel(null)}
                    className="w-8 h-8 flex items-center justify-center rounded hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
                  >
                    âœ•
                  </button>
                </div>
                <div className="flex-1 overflow-y-auto p-4">
                  <PlayerCharacterTab
                    campaigns={campaigns}
                    onAddToEncounter={async (pc) => {
                      if (!enc) return;
                      const id = crypto.randomUUID();
                      const c = {
                        id,
                        name: pc.name,
                        initiative: 0,
                        initiativeTieBreaker: 0,
                        hp: pc.hp || 0,
                        baseHP: pc.hp || 0,
                        tempHP: 0,
                        ac: pc.ac || 10,
                        isPlayer: true,
                        level: pc.level,
                        class: pc.class,
                        race: pc.race,
                        ...pc
                      };
                      await save({
                        ...enc,
                        combatants: { ...enc.combatants, [id]: c }
                      });
                      setActiveSidebarPanel(null);
                    }}
                  />
                </div>
              </div>
            )}
          </>
        )}

        {/* Middle Column - Creature Database (Prep Mode only) */}
        {!combatMode && (
          <div className="space-y-4">
            <div className="card bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-green-200 dark:border-green-800 h-[calc(100vh-120px)] flex flex-col overflow-hidden">
              <div className="flex items-center justify-between mb-3 flex-shrink-0">
                <h2 className="text-xl font-bold text-green-900 dark:text-green-300">
                  ðŸ‰ Creature Database
                </h2>
                <div className="flex gap-2">
                  <button
                    className="btn bg-purple-600 text-white hover:bg-purple-700 border-purple-600 text-xs px-2 py-1"
                    onClick={() => {
                      setEditingCreature(null);
                      setCreatureManagerInitialTab("players");
                      setShowCreatureManager(true);
                    }}
                    title="Player Characters"
                  >
                    ðŸ‘¥
                  </button>
                  <button
                    className="btn bg-orange-500 text-white hover:bg-orange-600 border-orange-500 text-xs px-2 py-1"
                    onClick={addCustom}
                    title="Add Custom Creature"
                  >
                    âž•
                  </button>
                  <button
                    className="btn bg-green-600 text-white hover:bg-green-700 border-green-600 text-xs px-2 py-1"
                    onClick={() => {
                      setEditingCreature(null);
                      setShowCreatureManager(true);
                    }}
                    title="Manage Creatures"
                  >
                    âš™ï¸
                  </button>
                </div>
              </div>

              {/* Campaign Players Quick Add */}
              {campaigns.length > 0 && enc && (
                <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-2 flex-shrink-0">
                  <div className="flex gap-2 items-center">
                    <select
                      value={selectedCampaignForBulkAdd || ''}
                      onChange={(e) => setSelectedCampaignForBulkAdd(e.target.value)}
                      className="flex-1 bg-white dark:bg-slate-800 border border-blue-300 dark:border-blue-700 rounded px-2 py-1 text-xs"
                    >
                      <option value="">Kampagne wÃ¤hlen...</option>
                      {campaigns.map(c => (
                        <option key={c.id} value={c.id}>{c.name}</option>
                      ))}
                    </select>
                    <button
                      onClick={() => {
                        if (selectedCampaignForBulkAdd) {
                          addCampaignPlayersToEncounter(selectedCampaignForBulkAdd);
                        }
                      }}
                      disabled={!selectedCampaignForBulkAdd || !enc || isAddingCampaignPlayers}
                      className="btn bg-blue-600 text-white hover:bg-blue-700 border-blue-600 text-xs px-3 py-1 disabled:bg-gray-400 disabled:cursor-not-allowed min-w-[80px]"
                    >
                      {isAddingCampaignPlayers ? (
                        <span className="inline-block animate-spin">â³</span>
                      ) : (
                        '+ Spieler'
                      )}
                    </button>
                  </div>
                </div>
              )}

              {/* Monster Browser - takes remaining space */}
              <div className="flex-1 overflow-hidden flex flex-col">
                <MonsterBrowser
                  onPick={addMonster}
                  onEdit={(monster) => {
                    setEditingCreature(monster);
                    setShowCreatureManager(true);
                  }}
                  RollableText={RollableText}
                  combatMode={combatMode}
                  selectedCombatant={selectedCombatant}
                />
              </div>
            </div>
          </div>
        )}

        {/* Middle/Right Column - Initiative Tracker (Combat) or Encounter Details (Prep) */}
        <section className="space-y-4 transition-all duration-500 ease-in-out">
          {!enc ? (
            <div className="card text-center py-12">
              <div className="text-6xl mb-4">âš”ï¸</div>
              <h3 className="text-xl font-semibold text-slate-700 dark:text-slate-300 mb-2">
                No encounter selected
              </h3>
              <p className="text-slate-500 dark:text-slate-400">
                Create a new encounter or select one from the sidebar
              </p>
            </div>
          ) : (
            <div className="space-y-4">
              {/* Encounter Header - Compact in Combat Mode */}
              {!combatMode && (
                <div className="card bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-900/20 dark:to-purple-900/20 border-blue-200 dark:border-blue-800">
                  <div className="flex items-center gap-2 flex-wrap">
                    <input
                      className="input flex-1 min-w-[200px] text-xl font-bold"
                      value={enc.name}
                      onChange={(e) => setEnc({ ...enc, name: e.target.value })}
                      placeholder="Encounter Name"
                    />
                    <button
                      className="btn bg-blue-500 text-white hover:bg-blue-600 border-blue-500 flex items-center gap-1"
                      onClick={async () => {
                        await save(enc);
                      }}
                      title="Speichern"
                    >
                      ðŸ’¾ Save
                    </button>
                  </div>
                </div>
              )}

              {/* Participants/Initiative - Always on right */}
              {order.length === 0 ? (
                <div className="card text-center py-8">
                  <p className="text-slate-500 dark:text-slate-400">
                    No combatants yet. Add monsters or custom combatants to
                    start!
                  </p>
                </div>
              ) : (
                <div className="space-y-4">
                  {/* Round Counter - Only in Combat Mode */}
                  {combatMode && (
                    <div className="sticky top-[4.5rem] z-[5] card bg-gradient-to-r from-orange-50 to-amber-50 dark:from-orange-900/90 dark:to-amber-900/90 border-orange-200 dark:border-orange-700 shadow-lg">
                      <div className="flex items-center gap-6 justify-center">
                        <button
                          className="w-10 h-10 flex items-center justify-center rounded-full bg-orange-200 dark:bg-orange-800 hover:bg-orange-300 dark:hover:bg-orange-700 transition-colors text-orange-700 dark:text-orange-300 font-bold"
                          onClick={prevTurn}
                        >
                          â—€
                        </button>
                        <div className="flex items-center gap-4">
                          <div className="text-center">
                            <div className="text-xs text-orange-600 dark:text-orange-400 font-bold uppercase tracking-wide">
                              Round
                            </div>
                            <div className="text-2xl font-bold text-orange-600 dark:text-orange-400">
                              {enc.round}
                            </div>
                          </div>
                          <div className="w-px h-10 bg-orange-300 dark:bg-orange-700"></div>
                          <div className="text-center">
                            <div className="text-xs text-orange-600 dark:text-orange-400 font-bold uppercase tracking-wide">
                              Turn
                            </div>
                            <div className="text-2xl font-bold text-orange-600 dark:text-orange-400">
                              {enc.turnIndex + 1}/{order.length}
                            </div>
                          </div>
                        </div>
                        <button
                          className="w-10 h-10 flex items-center justify-center rounded-full bg-orange-200 dark:bg-orange-800 hover:bg-orange-300 dark:hover:bg-orange-700 transition-colors text-orange-700 dark:text-orange-300 font-bold"
                          onClick={nextTurn}
                        >
                          â–¶
                        </button>
                      </div>
                    </div>
                  )}

                  {/* Combatants - Show differently based on mode */}
                  {combatMode ? (
                    /* Combat Mode - Full detailed cards */
                    <div className="grid gap-4">
                      {order.map((c, idx) => (
                        <CombatantRow
                          key={c.id}
                          c={c}
                          idx={idx}
                          active={
                            enc.initiativeOrder[idx] ===
                            enc.initiativeOrder[enc.turnIndex]
                          }
                          isSelected={selectedCombatantId === c.id}
                          onSelect={() =>
                            setSelectedCombatantId(
                              selectedCombatantId === c.id ? null : c.id
                            )
                          }
                          onChange={(patch) => updateCombatant(c.id, patch)}
                          onDamage={(amount) => applyDamage(c.id, amount)}
                          combatMode={combatMode}
                          allPlayers={order.filter(p => p.player)}
                        />
                      ))}
                    </div>
                  ) : (
                    /* Prep Mode - Compact list */
                    <div className="card">
                      <h2 className="text-lg font-semibold mb-3">
                        ðŸ“‹ Participants
                      </h2>
                      <div className="space-y-1">
                        {order.map((c, idx) => (
                          <CompactParticipantRow
                            key={c.id}
                            c={c}
                            idx={idx}
                            active={
                              enc.initiativeOrder[idx] ===
                              enc.initiativeOrder[enc.turnIndex]
                            }
                            isSelected={selectedCombatantId === c.id}
                            onSelect={() =>
                              setSelectedCombatantId(
                                selectedCombatantId === c.id ? null : c.id
                              )
                            }
                            showDelete={!combatMode}
                            onDelete={() => deleteCombatant(c.id)}
                          />
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
        </section>

      </main>



      {/* Dice Roll Toast - Right of the button */}
      {diceRollResult && diceRollResult.type === "generic" && (
        <div
          className="fixed bottom-6 left-24 z-40"
          style={{
            animation: "slideInFromBottom 0.25s ease-out, fadeOutScale 0.3s ease-in 2.7s forwards",
          }}
        >
          <div className="relative bg-slate-800 dark:bg-slate-900 border-2 border-slate-700 dark:border-slate-600 rounded-2xl shadow-2xl p-3 w-64 overflow-hidden">
            {/* Close button */}
            <button
              className="absolute top-1.5 right-1.5 w-5 h-5 rounded-full hover:bg-slate-700 dark:hover:bg-slate-600 flex items-center justify-center text-slate-400 hover:text-white transition-colors text-xs"
              onClick={() => {
                setDiceRollResult(null);
                if (toastDismissTimer) clearTimeout(toastDismissTimer);
              }}
            >
              âœ•
            </button>

            {/* Header */}
            <div className="flex items-center justify-between mb-2 pr-6">
              <div className="flex items-center gap-1.5">
                <span className="text-lg">ðŸŽ²</span>
                {diceRollResult.label && (
                  <span className="text-sm font-bold text-blue-300">{diceRollResult.label}</span>
                )}
                {diceRollResult.character && (
                  <span className="text-xs text-slate-400">({diceRollResult.character})</span>
                )}
                <span className="font-mono text-xs text-blue-400 dark:text-blue-300 font-bold">
                  {diceRollResult.notation}
                </span>
              </div>
              {diceRollResult.rollMode &&
                diceRollResult.rollMode !== "normal" && (
                  <span
                    className={`text-xs px-1.5 py-0.5 rounded-full ${
                      diceRollResult.rollMode === "advantage"
                        ? "bg-green-600"
                        : "bg-red-600"
                    } text-white font-semibold`}
                  >
                    {diceRollResult.rollMode === "advantage" ? "ADV" : "DIS"}
                  </span>
                )}
            </div>

            {/* Calculation breakdown - same as in history */}
            {diceRollResult.rolls &&
              diceRollResult.rolls.length > 0 &&
              (() => {
                const modifierMatch =
                  diceRollResult.notation?.match(/([+-]\d+)$/);
                const modifier = modifierMatch ? parseInt(modifierMatch[1]) : 0;
                const diceTotal = diceRollResult.rolls.reduce(
                  (sum, val) => sum + val,
                  0
                );

                return (
                  <div className="mb-2 text-center">
                    <div className="text-sm text-slate-300 dark:text-slate-400 font-mono">
                      {diceRollResult.rolls.length > 1 ? (
                        <>
                          [{diceRollResult.rolls.join(" + ")}]
                          {modifier !== 0 &&
                            ` ${modifier >= 0 ? "+" : ""}${modifier}`}
                          {" = "}
                          {diceTotal}
                          {modifier !== 0 &&
                            ` ${modifier >= 0 ? "+" : ""}${modifier} = ${
                              diceRollResult.total
                            }`}
                        </>
                      ) : (
                        <>
                          {diceRollResult.rolls[0]}
                          {modifier !== 0 &&
                            ` ${modifier >= 0 ? "+" : ""}${modifier} = ${
                              diceRollResult.total
                            }`}
                        </>
                      )}
                    </div>
                  </div>
                );
              })()}

            {/* Total */}
            <div className="text-center mb-1">
              <div className="text-4xl font-bold text-white">
                {diceRollResult.total}
              </div>
              {diceRollResult.rechargeResult && (
                <div
                  className={`text-sm font-semibold mt-2 ${
                    diceRollResult.rechargeResult.includes("âœ…")
                      ? "text-green-400"
                      : "text-red-400"
                  }`}
                >
                  {diceRollResult.rechargeResult}
                </div>
              )}
            </div>

            {/* Progress bar */}
            <div className="absolute bottom-0 left-0 right-0 h-1 bg-slate-700/50">
              <div className="h-full bg-gradient-to-r from-blue-500 to-purple-500 animate-[shrinkWidth_3s_linear]"></div>
            </div>
          </div>
        </div>
      )}

      {/* Other roll notifications (concentration, death saves) */}
      {diceRollResult && diceRollResult.type !== "generic" && (
        <div className="fixed top-20 right-1/2 translate-x-1/2 z-40 animate-[bounceIn_0.4s_cubic-bezier(0.68,-0.55,0.265,1.55)]">
          <div
            className={`card min-w-[300px] ${
              diceRollResult.passed !== undefined
                ? diceRollResult.passed
                  ? "bg-green-50 dark:bg-green-900 border-green-300 dark:border-green-700"
                  : "bg-red-50 dark:bg-red-900 border-red-300 dark:border-red-700"
                : "bg-blue-50 dark:bg-blue-900 border-blue-300 dark:border-blue-700"
            }`}
          >
            <div className="text-center">
              <div className="text-sm font-semibold text-slate-700 dark:text-slate-200 mb-2">
                {diceRollResult.type === "concentration" &&
                  "ðŸŽ² Concentration Check"}
                {diceRollResult.type === "deathSave" && "ðŸ’€ Death Save"}
              </div>
              {diceRollResult.name && (
                <div className="text-lg font-medium text-slate-900 dark:text-slate-100 mb-1">
                  {diceRollResult.name}
                </div>
              )}
              <div className="flex items-center justify-center gap-2 mb-2">
                <span className="text-3xl font-bold text-blue-600 dark:text-blue-400">
                  {diceRollResult.roll}
                </span>
                {diceRollResult.modifier && diceRollResult.modifier !== 0 && (
                  <>
                    <span className="text-xl text-slate-400">+</span>
                    <span className="text-2xl font-semibold">
                      {diceRollResult.modifier}
                    </span>
                  </>
                )}
                {diceRollResult.total && (
                  <>
                    <span className="text-xl text-slate-400">=</span>
                    <span className="text-3xl font-bold text-slate-900 dark:text-slate-100">
                      {diceRollResult.total}
                    </span>
                  </>
                )}
              </div>
              {diceRollResult.dc && (
                <div className="text-sm text-slate-600 dark:text-slate-300">
                  DC {diceRollResult.dc} â€¢{" "}
                  {diceRollResult.passed ? "âœ… Success" : "âŒ Failed"}
                </div>
              )}
              {!diceRollResult.passed &&
                diceRollResult.type === "concentration" && (
                  <div className="mt-2 text-sm text-red-700 dark:text-red-300 font-medium">
                    Concentration lost!
                  </div>
                )}
              {diceRollResult.critical &&
                diceRollResult.type === "deathSave" && (
                  <div
                    className={`mt-2 text-sm font-medium ${
                      diceRollResult.passed
                        ? "text-green-700 dark:text-green-300"
                        : "text-red-700 dark:text-red-300"
                    }`}
                  >
                    {diceRollResult.passed
                      ? "ðŸŽ‰ Natural 20! Regain 1 HP"
                      : "ðŸ’€ Natural 1! Two failures"}
                  </div>
                )}
              <button
                className="mt-3 btn w-full"
                onClick={() => setDiceRollResult(null)}
              >
                Dismiss
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Dice Roller - 2D or 3D based on settings */}
      {showDiceRoller && settings.diceRollerType === "2d" && (
        <FantasticDiceRoller
          initialNotation={diceRollerInitialNotation}
          autoRoll={diceRollerAutoRoll}
          initialRollMode={diceRollerInitialRollMode}
          dddiceInstance={dddiceRef.current}
          dddiceReady={dddiceReady}
          onClose={() => {
            setShowDiceRoller(false);
            setDiceRollerInitialNotation(null);
            setDiceRollerAutoRoll(false);
            setDiceRollerInitialRollMode("normal");
            setDiceRollerLabel('');
            setDiceRollerCharacter('');
          }}
          onResult={(result) => {
            // Check if this is an auto-recharge roll (from Next Turn)
            if (window._pendingAutoRecharge && result.notation === "1d6") {
              const {
                actionName,
                combatantName,
                rechargeTrigger,
                combatantId,
                rechargeKey,
                recharges,
              } = window._pendingAutoRecharge;
              const roll = result.total; // Use the REAL dice roller result
              const success = roll >= rechargeTrigger;

              // Update combatant recharge status with REAL result
              updateCombatant(combatantId, {
                recharges: { ...recharges, [rechargeKey]: success },
              });

              // Show result notification with full context
              const rollResult = {
                type: "generic",
                roll: result.rolls[0],
                total: result.total,
                rolls: result.rolls,
                notation: `${combatantName}: ${actionName} (Recharge ${rechargeTrigger}+)`,
                rollMode: result.rollMode,
                timestamp: Date.now(),
                rechargeResult: success ? "âœ… Recharged!" : "âŒ Not recharged",
              };
              setDiceRollResult(rollResult);
              setRollHistory((prev) => [rollResult, ...prev].slice(0, 10));

              // Clear auto-recharge context
              delete window._pendingAutoRecharge;

              // Auto-dismiss after 3 seconds
              if (toastDismissTimer) clearTimeout(toastDismissTimer);
              const timer = setTimeout(() => {
                setDiceRollResult(null);
              }, 3000);
              setToastDismissTimer(timer);
            }
            // Check if this is a manual recharge roll (from detail panel)
            else if (window._pendingRecharge && result.notation === "1d6") {
              const { combatantId, rechargeKey, rechargeTrigger, recharges } =
                window._pendingRecharge;
              const roll = result.total;
              const success = roll >= rechargeTrigger;

              // Update combatant
              updateCombatant(combatantId, {
                recharges: { ...recharges, [rechargeKey]: success },
              });

              // Show result notification
              const rollResult = {
                type: "generic",
                roll: result.rolls[0],
                total: result.total,
                rolls: result.rolls,
                notation: `${result.notation} (Recharge ${rechargeTrigger}+)`,
                rollMode: result.rollMode,
                timestamp: Date.now(),
                rechargeResult: success ? "âœ… Recharged!" : "âŒ Not recharged",
              };
              setDiceRollResult(rollResult);
              setRollHistory((prev) => [rollResult, ...prev].slice(0, 10));

              // Clear pending recharge
              delete window._pendingRecharge;

              // Auto-dismiss after 3 seconds
              if (toastDismissTimer) clearTimeout(toastDismissTimer);
              const timer = setTimeout(() => {
                setDiceRollResult(null);
              }, 3000);
              setToastDismissTimer(timer);
            } else {
              // Normal roll
              const rollResult = {
                type: "generic",
                roll: result.rolls[0],
                total: result.total,
                rolls: result.rolls,
                notation: result.notation,
                rollMode: result.rollMode,
                label: diceRollerLabel,
                character: diceRollerCharacter,
                timestamp: Date.now(),
              };
              setDiceRollResult(rollResult);
              // Add to history (keep last 10 rolls)
              setRollHistory((prev) => [rollResult, ...prev].slice(0, 10));

              // Auto-dismiss after 3 seconds
              if (toastDismissTimer) clearTimeout(toastDismissTimer);
              const timer = setTimeout(() => {
                setDiceRollResult(null);
              }, 3000);
              setToastDismissTimer(timer);
            }
          }}
        />
      )}

      {/* 3D Dice Roller */}
      {showDiceRoller && settings.diceRollerType === "3d" && (
        <DiceRollerDDDice
          initialNotation={diceRollerInitialNotation}
          initialRollMode={diceRollerInitialRollMode}
          dddiceInstance={dddiceRef.current}
          dddiceReady={dddiceReady}
          autoRoll={diceRollerAutoRoll}
          onClose={() => {
            setShowDiceRoller(false);
            setDiceRollerInitialNotation(null);
            setDiceRollerAutoRoll(false);
            setDiceRollerInitialRollMode("normal");
          }}
          onResult={(result) => {
            // Check if this is an auto-recharge roll (from Next Turn)
            if (window._pendingAutoRecharge && result.notation === "1d6") {
              const {
                actionName,
                combatantName,
                rechargeTrigger,
                combatantId,
                rechargeKey,
                recharges,
              } = window._pendingAutoRecharge;
              const roll = result.total;
              const success = roll >= rechargeTrigger;

              updateCombatant(combatantId, {
                recharges: { ...recharges, [rechargeKey]: success },
              });

              const rollResult = {
                type: "generic",
                roll: result.rolls[0],
                total: result.total,
                rolls: result.rolls,
                notation: `${combatantName}: ${actionName} (Recharge ${rechargeTrigger}+)`,
                rollMode: result.rollMode,
                timestamp: Date.now(),
                rechargeResult: success ? "âœ… Recharged!" : "âŒ Not recharged",
              };
              setDiceRollResult(rollResult);
              setRollHistory((prev) => [rollResult, ...prev].slice(0, 10));

              delete window._pendingAutoRecharge;

              if (toastDismissTimer) clearTimeout(toastDismissTimer);
              const timer = setTimeout(() => {
                setDiceRollResult(null);
              }, 3000);
              setToastDismissTimer(timer);
            } else {
              const rollResult = {
                type: "generic",
                roll: result.rolls[0],
                total: result.total,
                rolls: result.rolls,
                notation: result.notation,
                rollMode: result.rollMode,
                label: diceRollerLabel,
                character: diceRollerCharacter,
                timestamp: Date.now(),
              };
              setDiceRollResult(rollResult);
              setRollHistory((prev) => [rollResult, ...prev].slice(0, 10));

              if (toastDismissTimer) clearTimeout(toastDismissTimer);
              const timer = setTimeout(() => {
                setDiceRollResult(null);
              }, 3000);
              setToastDismissTimer(timer);
            }
          }}
        />
      )}

      {/* Settings Modal */}
      <Settings isOpen={showSettings} onClose={() => setShowSettings(false)} />

      {/* Floating Action Buttons */}
      <div className="fixed bottom-6 left-6 z-30 flex flex-col gap-3">
        <button
          className="dice-roller-button w-16 h-16 bg-gradient-to-br from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 text-white rounded-full shadow-2xl flex items-center justify-center text-3xl transition-all hover:scale-110 active:scale-95"
          onClick={() => setShowDiceRoller(!showDiceRoller)}
          title="Dice Roller"
        >
          ðŸŽ²
        </button>
        {rollHistory.length > 0 && (
          <button
            className="roll-history-button w-12 h-12 bg-slate-700 hover:bg-slate-600 dark:bg-slate-600 dark:hover:bg-slate-500 text-white rounded-full shadow-xl flex items-center justify-center text-lg transition-all hover:scale-110 active:scale-95 relative"
            onClick={() => setShowRollHistory(!showRollHistory)}
            title="Roll History"
          >
            ðŸ“œ
            <span className="absolute -top-1 -right-1 w-5 h-5 bg-blue-600 text-white text-xs font-bold rounded-full flex items-center justify-center">
              {rollHistory.length}
            </span>
          </button>
        )}
      </div>

      {/* Roll History Panel */}
      {showRollHistory && (
        <div className="roll-history-container fixed bottom-24 left-6 z-40 bg-slate-800/98 dark:bg-slate-900/98 backdrop-blur-lg border-2 border-slate-700 dark:border-slate-600 rounded-2xl shadow-2xl p-4 w-80 max-h-96 overflow-y-auto animate-[slideInLeft_0.3s_ease-out]">
          <div className="flex items-center justify-between mb-3">
            <h3 className="text-white font-bold text-lg">Roll History</h3>
            <div className="flex items-center gap-2">
              <button
                className="px-3 py-1 text-xs font-semibold bg-red-600 hover:bg-red-700 text-white rounded transition-colors"
                onClick={async () => {
                  if (
                    await confirm(
                      "MÃ¶chtest du die gesamte WÃ¼rfel-Historie wirklich lÃ¶schen?"
                    )
                  ) {
                    setRollHistory([]);
                  }
                }}
                title="Clear History"
              >
                Clear
              </button>
              <button
                className="w-6 h-6 rounded-full hover:bg-slate-700 dark:hover:bg-slate-600 flex items-center justify-center text-slate-400 hover:text-white transition-colors"
                onClick={() => setShowRollHistory(false)}
              >
                âœ•
              </button>
            </div>
          </div>
          <div className="space-y-2">
            {rollHistory.map((roll, index) => (
              <div
                key={roll.timestamp}
                className="bg-slate-700/50 dark:bg-slate-800/50 rounded-lg p-3 border border-slate-600 dark:border-slate-700"
              >
                <div className="flex items-start justify-between gap-3">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      {roll.label && (
                        <span className="text-sm font-bold text-blue-300">{roll.label}</span>
                      )}
                      {roll.character && (
                        <span className="text-xs text-slate-400">({roll.character})</span>
                      )}
                      <span className="font-mono text-xs text-blue-400 dark:text-blue-300 font-semibold">
                        {roll.notation}
                      </span>
                      {roll.rollMode && roll.rollMode !== "normal" && (
                        <span
                          className={`text-xs px-1.5 py-0.5 rounded-full ${
                            roll.rollMode === "advantage"
                              ? "bg-green-600"
                              : "bg-red-600"
                          } text-white font-semibold`}
                        >
                          {roll.rollMode === "advantage" ? "ADV" : "DIS"}
                        </span>
                      )}
                    </div>
                    {roll.rolls &&
                      roll.rolls.length > 0 &&
                      (() => {
                        const modifierMatch =
                          roll.notation?.match(/([+-]\d+)$/);
                        const modifier = modifierMatch
                          ? parseInt(modifierMatch[1])
                          : 0;
                        const diceTotal = roll.rolls.reduce(
                          (sum, val) => sum + val,
                          0
                        );

                        return (
                          <div className="text-xs text-slate-300 dark:text-slate-400 font-mono">
                            {roll.rolls.length > 1 ? (
                              <>
                                [{roll.rolls.join(" + ")}]
                                {modifier !== 0 &&
                                  ` ${modifier >= 0 ? "+" : ""}${modifier}`}
                                {" = "}
                                {diceTotal}
                                {modifier !== 0 &&
                                  ` ${modifier >= 0 ? "+" : ""}${modifier} = ${
                                    roll.total
                                  }`}
                              </>
                            ) : (
                              <>
                                {roll.rolls[0]}
                                {modifier !== 0 &&
                                  ` ${modifier >= 0 ? "+" : ""}${modifier} = ${
                                    roll.total
                                  }`}
                              </>
                            )}
                          </div>
                        );
                      })()}
                  </div>
                  <div className="text-3xl font-bold text-white tabular-nums">
                    {roll.total}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Spell Tooltip (Hover) */}
      {spellTooltip.spell && (
        <div
          className="fixed z-50 bg-white dark:bg-slate-800 rounded-lg shadow-2xl border-2 border-purple-500 dark:border-purple-700 p-4 max-h-96 overflow-y-auto pointer-events-none"
          style={{
            left: `${spellTooltip.x}px`,
            top: `${spellTooltip.y}px`,
            width: "634px",
          }}
        >
          <div className="space-y-2">
            <div className="flex items-baseline gap-2">
              <h3 className="text-lg font-bold text-purple-900 dark:text-purple-300">
                {spellTooltip.spell.name}
              </h3>
              <span className="text-xs text-purple-700 dark:text-purple-400">
                {spellTooltip.spell.level === 0
                  ? "Cantrip"
                  : `Level ${spellTooltip.spell.level}`}
              </span>
            </div>

            <div className="grid grid-cols-2 gap-2 text-xs border-t border-purple-200 dark:border-purple-800 pt-2">
              <div>
                <span className="font-semibold text-purple-800 dark:text-purple-300">
                  Casting:
                </span>
                <span className="ml-1 text-slate-700 dark:text-slate-300">
                  {(() => {
                    // encounterpp format
                    if (spellTooltip.spell.castingTime) {
                      return spellTooltip.spell.castingTime;
                    }
                    // 5e.tools format fallback
                    if (spellTooltip.spell.time?.[0]) {
                      return `${spellTooltip.spell.time[0].number} ${spellTooltip.spell.time[0].unit}`;
                    }
                    return "â€”";
                  })()}
                </span>
              </div>
              <div>
                <span className="font-semibold text-purple-800 dark:text-purple-300">
                  Range:
                </span>
                <span className="ml-1 text-slate-700 dark:text-slate-300">
                  {(() => {
                    // encounterpp format (already a string)
                    if (typeof spellTooltip.spell.range === "string") {
                      return spellTooltip.spell.range;
                    }

                    // 5e.tools format fallback
                    const range = spellTooltip.spell.range;
                    if (!range) return "â€”";

                    // Handle point-based range
                    if (range.type === "point") {
                      const dist = range.distance;
                      if (dist.type === "self") {
                        return "Self";
                      }
                      if (dist.amount) {
                        return `${dist.amount} ${dist.type}`;
                      }
                      return dist.type;
                    }

                    // Handle area effects (cone, line, sphere, cube, etc.)
                    if (
                      range.type === "cone" ||
                      range.type === "line" ||
                      range.type === "sphere" ||
                      range.type === "cube" ||
                      range.type === "hemisphere" ||
                      range.type === "radius"
                    ) {
                      const dist = range.distance;
                      if (dist && dist.amount) {
                        return `Self (${dist.amount}-${dist.type} ${range.type})`;
                      }
                      return `Self (${range.type})`;
                    }

                    return range.type === "self" ? "Self" : range.type;
                  })()}
                </span>
              </div>
            </div>

            <div className="text-xs text-slate-700 dark:text-slate-300 border-t border-purple-200 dark:border-purple-800 pt-2 max-h-48 overflow-y-auto">
              {(() => {
                // Helper function to remove dice notation and 5etools tags
                const cleanText = (text) => {
                  if (!text) return "";
                  return (
                    text
                      // Remove 5etools tags like {@damage 2d8}, {@spell fireball}, etc.
                      .replace(/\{@[^}]+\}/g, (match) => {
                        const textMatch = match.match(
                          /\{@\w+\s+([^}|]+)(?:\|[^}]+)?\}/
                        );
                        return textMatch ? textMatch[1] : match;
                      })
                      // Remove table dict notation
                      .replace(/\{'type':\s*'table'[^}]*\}/g, "[Table]")
                      // Clean up extra whitespace
                      .replace(/\s+/g, " ")
                      .trim()
                  );
                };

                // encounterpp format
                if (spellTooltip.spell.description) {
                  return (
                    <p className="leading-relaxed">
                      {cleanText(spellTooltip.spell.description)}
                    </p>
                  );
                }
                // 5e.tools format fallback
                if (spellTooltip.spell.entries?.[0]) {
                  return (
                    <p className="leading-relaxed">
                      {typeof spellTooltip.spell.entries[0] === "string"
                        ? cleanText(spellTooltip.spell.entries[0])
                        : ""}
                    </p>
                  );
                }
                return null;
              })()}
            </div>

            <div className="text-xs text-slate-500 dark:text-slate-400 border-t border-purple-200 dark:border-purple-800 pt-1">
              {(() => {
                // encounterpp format
                if (spellTooltip.spell.meta?.source) {
                  return `${spellTooltip.spell.meta.source}${
                    spellTooltip.spell.meta.page
                      ? ` p${spellTooltip.spell.meta.page}`
                      : ""
                  }`;
                }
                // 5e.tools format fallback
                return `${spellTooltip.spell.source || ""}${
                  spellTooltip.spell.page ? ` p${spellTooltip.spell.page}` : ""
                }`;
              })()}
            </div>
          </div>
        </div>
      )}

      {/* Source Tooltip (Hover) */}
      {sourceTooltip.source && (
        <div
          className="fixed z-50 bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-slate-800 dark:to-slate-900 rounded-xl shadow-2xl border-2 border-blue-400 dark:border-blue-600 p-5 pointer-events-none"
          style={{
            left: `${sourceTooltip.x}px`,
            top: `${sourceTooltip.y}px`,
            width: "320px",
          }}
        >
          <div className="space-y-3">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-blue-500 dark:bg-blue-600 flex items-center justify-center flex-shrink-0">
                <svg
                  className="w-6 h-6 text-white"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
              </div>
              <div className="flex-1">
                <div className="text-xs font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wider mb-1">
                  Source Book
                </div>
                <div className="text-lg font-bold text-blue-900 dark:text-blue-100 leading-tight">
                  {sourceTooltip.fullName || sourceTooltip.source}
                </div>
              </div>
            </div>

            <div className="border-t-2 border-blue-200 dark:border-blue-800 pt-3">
              <div className="flex items-center gap-2 text-sm">
                <span className="px-2.5 py-1 bg-blue-200 dark:bg-blue-900/60 text-blue-800 dark:text-blue-300 rounded-md font-mono font-semibold">
                  {sourceTooltip.source}
                </span>
                <span className="text-blue-600 dark:text-blue-400 text-xs">
                  abbreviation
                </span>
              </div>
            </div>

            <div className="flex items-center gap-2 text-xs text-blue-700 dark:text-blue-300 bg-blue-100 dark:bg-blue-950/50 rounded-lg px-3 py-2">
              <svg
                className="w-4 h-4 flex-shrink-0"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              <span className="leading-relaxed">
                Click to view all monsters from this source
              </span>
            </div>
          </div>
        </div>
      )}

      {/* Initiative Tooltip */}
      {initiativeTooltip.show && (
        <div
          className="fixed z-50 bg-gradient-to-br from-blue-500 to-indigo-600 dark:from-blue-700 dark:to-indigo-800 rounded-xl shadow-2xl border-2 border-blue-300 dark:border-blue-500 p-4 pointer-events-none animate-[fadeIn_0.15s_ease-out]"
          style={{
            right: `${window.innerWidth - initiativeTooltip.x + 15}px`,
            top: `${initiativeTooltip.y + 15}px`,
            minWidth: "240px",
          }}
        >
          <div className="space-y-3">
            {/* Title */}
            <div className="flex items-center gap-2 pb-2 border-b-2 border-white/30">
              <svg
                className="w-5 h-5 text-white"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M13 10V3L4 14h7v7l9-11h-7z"
                />
              </svg>
              <span className="text-sm font-bold text-white uppercase tracking-wider">
                Initiative Roll
              </span>
            </div>

            {/* Roll Breakdown */}
            <div className="space-y-2">
              <div className="flex items-center justify-between text-white">
                <span className="text-sm font-medium opacity-90">
                  ðŸŽ² d20 Roll:
                </span>
                <span className="text-xl font-bold px-3 py-1 bg-white/20 rounded-lg">
                  {initiativeTooltip.roll}
                </span>
              </div>

              <div className="flex items-center justify-center text-white text-lg">
                <span className="font-bold">+</span>
              </div>

              <div className="flex items-center justify-between text-white">
                <span className="text-sm font-medium opacity-90">
                  âš¡ Bonus:
                </span>
                <span className="text-xl font-bold px-3 py-1 bg-white/20 rounded-lg">
                  {initiativeTooltip.bonus >= 0 ? '+' : ''}{initiativeTooltip.bonus}
                </span>
              </div>

              <div className="border-t-2 border-white/30 pt-2 mt-2">
                <div className="flex items-center justify-between text-white">
                  <span className="text-sm font-bold">
                    = Total:
                  </span>
                  <span className="text-2xl font-bold px-4 py-1 bg-white/30 rounded-lg shadow-lg">
                    {initiativeTooltip.total}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* AC Tooltip */}
      {acTooltip.show && (
        <div
          className="fixed z-50 bg-gradient-to-br from-green-500 to-emerald-600 dark:from-green-700 dark:to-emerald-800 rounded-xl shadow-2xl border-2 border-green-300 dark:border-green-500 p-4 pointer-events-none animate-[fadeIn_0.15s_ease-out]"
          style={{
            right: `${window.innerWidth - acTooltip.x + 15}px`,
            top: `${acTooltip.y + 15}px`,
            minWidth: "220px",
          }}
        >
          <div className="space-y-3">
            {/* Title */}
            <div className="flex items-center gap-2 pb-2 border-b-2 border-white/30">
              <svg
                className="w-5 h-5 text-white"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"
                />
              </svg>
              <span className="text-sm font-bold text-white uppercase tracking-wider">
                Armor Class
              </span>
            </div>

            {/* AC Value */}
            <div className="flex items-center justify-center">
              <span className="text-4xl font-bold text-white px-4 py-2 bg-white/20 rounded-lg shadow-lg">
                {acTooltip.ac}
              </span>
            </div>

            {/* Armor Type */}
            {acTooltip.armorType && Array.isArray(acTooltip.armorType) && acTooltip.armorType.length > 0 && (
              <div className="border-t-2 border-white/30 pt-2">
                <div className="text-white text-sm">
                  <span className="font-semibold opacity-90">ðŸ›¡ï¸ Source:</span>
                  <div className="mt-1 flex flex-wrap gap-1">
                    {acTooltip.armorType.map((source, idx) => (
                      <span
                        key={idx}
                        className="px-2 py-1 bg-white/20 rounded text-xs font-medium"
                      >
                        {source}
                      </span>
                    ))}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* HP Tooltip */}
      {hpTooltip.show && (
        <div
          className="fixed z-50 bg-gradient-to-br from-red-500 to-rose-600 dark:from-red-700 dark:to-rose-800 rounded-xl shadow-2xl border-2 border-red-300 dark:border-red-500 p-4 pointer-events-none animate-[fadeIn_0.15s_ease-out]"
          style={{
            right: `${window.innerWidth - hpTooltip.x + 15}px`,
            top: `${hpTooltip.y + 15}px`,
            minWidth: "240px",
          }}
        >
          <div className="space-y-3">
            {/* Title */}
            <div className="flex items-center gap-2 pb-2 border-b-2 border-white/30">
              <svg
                className="w-5 h-5 text-white"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"
                />
              </svg>
              <span className="text-sm font-bold text-white uppercase tracking-wider">
                Hit Points
              </span>
            </div>

            {/* HP Values */}
            <div className="space-y-2">
              <div className="flex items-center justify-between text-white">
                <span className="text-sm font-medium opacity-90">
                  â¤ï¸ Current:
                </span>
                <span className="text-xl font-bold px-3 py-1 bg-white/20 rounded-lg">
                  {hpTooltip.current}
                </span>
              </div>

              <div className="flex items-center justify-between text-white">
                <span className="text-sm font-medium opacity-90">
                  ðŸ’ª Maximum:
                </span>
                <span className="text-xl font-bold px-3 py-1 bg-white/20 rounded-lg">
                  {hpTooltip.max}
                </span>
              </div>

              {/* Hit Dice */}
              {hpTooltip.hitDice && (
                <div className="border-t-2 border-white/30 pt-2 mt-2">
                  <div className="text-white text-sm">
                    <span className="font-semibold opacity-90">ðŸŽ² Hit Dice:</span>
                    <div className="mt-1 px-3 py-2 bg-white/20 rounded-lg font-mono text-base font-bold text-center">
                      {hpTooltip.hitDice}
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Spell Details Modal */}
      {showSpellModal && selectedSpell && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm"
          onClick={() => setShowSpellModal(false)}
        >
          <div
            className="bg-white dark:bg-slate-800 rounded-lg shadow-2xl border-2 border-purple-500 dark:border-purple-700 w-full max-w-2xl max-h-[90vh] overflow-y-auto m-4"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="sticky top-0 bg-purple-600 dark:bg-purple-700 text-white p-4 flex items-center justify-between border-b-2 border-purple-700 dark:border-purple-800">
              <div>
                <h2 className="text-2xl font-bold">{selectedSpell.name}</h2>
                <div className="text-sm opacity-90 mt-1">
                  {selectedSpell.level === 0
                    ? "Cantrip"
                    : `Level ${selectedSpell.level}`}
                  {" â€¢ "}
                  {{
                    A: "Abjuration",
                    C: "Conjuration",
                    D: "Divination",
                    E: "Enchantment",
                    V: "Evocation",
                    I: "Illusion",
                    N: "Necromancy",
                    T: "Transmutation",
                  }[selectedSpell.school] || selectedSpell.school}
                </div>
              </div>
              <button
                className="w-8 h-8 rounded-full hover:bg-purple-700 dark:hover:bg-purple-600 flex items-center justify-center transition-colors"
                onClick={() => setShowSpellModal(false)}
              >
                âœ•
              </button>
            </div>

            <div className="p-6 space-y-4">
              {/* Casting info */}
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <span className="font-semibold text-purple-800 dark:text-purple-300">
                    Casting Time:
                  </span>
                  <span className="ml-2 text-slate-700 dark:text-slate-300">
                    {(() => {
                      // encounterpp format
                      if (selectedSpell.castingTime) {
                        return selectedSpell.castingTime;
                      }
                      // 5e.tools format fallback
                      if (selectedSpell.time && selectedSpell.time[0]) {
                        return `${selectedSpell.time[0].number} ${selectedSpell.time[0].unit}`;
                      }
                      return "â€”";
                    })()}
                  </span>
                </div>
                <div>
                  <span className="font-semibold text-purple-800 dark:text-purple-300">
                    Range:
                  </span>
                  <span className="ml-2 text-slate-700 dark:text-slate-300">
                    {(() => {
                      // encounterpp format (already a string)
                      if (typeof selectedSpell.range === "string") {
                        return selectedSpell.range;
                      }
                      // 5e.tools format fallback
                      if (selectedSpell.range?.type === "point") {
                        return `${selectedSpell.range.distance.amount} ${selectedSpell.range.distance.type}`;
                      }
                      return selectedSpell.range?.type === "self"
                        ? "Self"
                        : selectedSpell.range?.type || "â€”";
                    })()}
                  </span>
                </div>
                <div>
                  <span className="font-semibold text-purple-800 dark:text-purple-300">
                    Components:
                  </span>
                  <span className="ml-2 text-slate-700 dark:text-slate-300">
                    {(() => {
                      // encounterpp format
                      if (
                        selectedSpell.components &&
                        typeof selectedSpell.components === "object" &&
                        ("verbal" in selectedSpell.components ||
                          "somatic" in selectedSpell.components ||
                          "material" in selectedSpell.components)
                      ) {
                        const comps = [
                          selectedSpell.components.verbal && "V",
                          selectedSpell.components.somatic && "S",
                          selectedSpell.components.material && "M",
                        ]
                          .filter(Boolean)
                          .join(", ");
                        const materialText =
                          selectedSpell.components.materialText;
                        return (
                          <>
                            {comps || "â€”"}
                            {materialText && (
                              <span className="text-xs italic">
                                {" "}
                                ({materialText})
                              </span>
                            )}
                          </>
                        );
                      }
                      // 5e.tools format fallback
                      const comps = [
                        selectedSpell.components?.v && "V",
                        selectedSpell.components?.s && "S",
                        selectedSpell.components?.m && "M",
                      ]
                        .filter(Boolean)
                        .join(", ");
                      return (
                        <>
                          {comps || "â€”"}
                          {selectedSpell.components?.m &&
                            typeof selectedSpell.components.m === "string" && (
                              <span className="text-xs italic">
                                {" "}
                                ({selectedSpell.components.m})
                              </span>
                            )}
                        </>
                      );
                    })()}
                  </span>
                </div>
                <div>
                  <span className="font-semibold text-purple-800 dark:text-purple-300">
                    Duration:
                  </span>
                  <span className="ml-2 text-slate-700 dark:text-slate-300">
                    {(() => {
                      // encounterpp format (already a string)
                      if (typeof selectedSpell.duration === "string") {
                        return selectedSpell.duration;
                      }
                      // 5e.tools format fallback
                      if (selectedSpell.duration && selectedSpell.duration[0]) {
                        const dur = selectedSpell.duration[0];
                        if (dur.type === "instant") {
                          return "Instantaneous";
                        }
                        if (dur.concentration) {
                          return `Concentration, up to ${
                            dur.duration?.amount || ""
                          } ${dur.duration?.type || ""}`;
                        }
                        return `${dur.duration?.amount || ""} ${
                          dur.duration?.type || ""
                        }`;
                      }
                      return "â€”";
                    })()}
                  </span>
                </div>
              </div>

              {/* Description */}
              <div className="border-t border-slate-200 dark:border-slate-700 pt-4">
                <div className="text-slate-700 dark:text-slate-300 space-y-2">
                  {(() => {
                    // encounterpp format
                    if (selectedSpell.description) {
                      // Parse description for embedded tables (Python dict format)
                      const parseDescriptionWithTables = (desc) => {
                        // Look for table dict pattern: {'type': 'table', ...}
                        const tablePattern =
                          /\{'type':\s*'table'[^}]*'caption':\s*'([^']+)'[^}]*'colLabels':\s*\[([^\]]+)\][^}]*'rows':\s*\[(\[.*?\])\]\}/g;

                        const parts = [];
                        let lastIndex = 0;
                        let match;

                        while ((match = tablePattern.exec(desc)) !== null) {
                          // Add text before table
                          if (match.index > lastIndex) {
                            const text = desc
                              .substring(lastIndex, match.index)
                              .trim();
                            if (text) {
                              parts.push({ type: "text", content: text });
                            }
                          }

                          // Parse table
                          try {
                            const caption = match[1];
                            const colLabelsStr = match[2];
                            const rowsStr = match[3];

                            // Extract column labels
                            const colLabels = colLabelsStr
                              .match(/'([^']+)'/g)
                              .map((s) => s.slice(1, -1));

                            // Extract rows (simplified parsing)
                            const rows = [];
                            const rowMatches = rowsStr.match(/\[([^\]]+)\]/g);
                            if (rowMatches) {
                              rowMatches.forEach((rowStr) => {
                                const cells = rowStr.match(/'([^']+)'/g);
                                if (cells) {
                                  rows.push(cells.map((s) => s.slice(1, -1)));
                                }
                              });
                            }

                            parts.push({
                              type: "table",
                              caption,
                              colLabels,
                              rows,
                            });
                          } catch (e) {
                            console.error("Failed to parse table:", e);
                          }

                          lastIndex = match.index + match[0].length;
                        }

                        // Add remaining text
                        if (lastIndex < desc.length) {
                          const text = desc.substring(lastIndex).trim();
                          if (text) {
                            parts.push({ type: "text", content: text });
                          }
                        }

                        return parts.length > 0
                          ? parts
                          : [{ type: "text", content: desc }];
                      };

                      const parts = parseDescriptionWithTables(
                        selectedSpell.description
                      );

                      return (
                        <>
                          {parts.map((part, idx) => {
                            if (part.type === "table") {
                              // Clean up 5etools tags from table cells
                              const cleanCell = (cell) => {
                                return cell.replace(/\{@[^}]+\}/g, (match) => {
                                  const textMatch = match.match(
                                    /\{@\w+\s+([^}|]+)(?:\|[^}]+)?\}/
                                  );
                                  return textMatch ? textMatch[1] : match;
                                });
                              };

                              return (
                                <div key={idx} className="my-4 overflow-x-auto">
                                  <div className="font-semibold text-purple-900 dark:text-purple-300 mb-2">
                                    {part.caption}
                                  </div>
                                  <table className="min-w-full border border-purple-200 dark:border-purple-800 rounded-lg overflow-hidden">
                                    <thead className="bg-purple-100 dark:bg-purple-900/40">
                                      <tr>
                                        {part.colLabels.map((label, colIdx) => (
                                          <th
                                            key={colIdx}
                                            className="px-3 py-2 text-left text-xs font-semibold text-purple-900 dark:text-purple-300 border-b border-purple-200 dark:border-purple-800"
                                          >
                                            {label}
                                          </th>
                                        ))}
                                      </tr>
                                    </thead>
                                    <tbody className="bg-white dark:bg-slate-900">
                                      {part.rows.map((row, rowIdx) => (
                                        <tr
                                          key={rowIdx}
                                          className="border-b border-purple-100 dark:border-purple-900/50 hover:bg-purple-50 dark:hover:bg-purple-900/20"
                                        >
                                          {row.map((cell, cellIdx) => (
                                            <td
                                              key={cellIdx}
                                              className="px-3 py-2 text-sm"
                                            >
                                              <RollableText
                                                text={cleanCell(cell)}
                                              />
                                            </td>
                                          ))}
                                        </tr>
                                      ))}
                                    </tbody>
                                  </table>
                                </div>
                              );
                            } else {
                              return (
                                <p key={idx} className="leading-relaxed">
                                  <RollableText
                                    text={part.content}
                                    onRoll={() => setShowSpellModal(false)}
                                  />
                                </p>
                              );
                            }
                          })}
                          {selectedSpell.higherLevel && (
                            <div className="bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800 rounded p-3">
                              <div className="font-semibold text-purple-900 dark:text-purple-300 mb-1">
                                At Higher Levels
                              </div>
                              <p className="text-sm">
                                <RollableText
                                  text={selectedSpell.higherLevel}
                                  onRoll={() => setShowSpellModal(false)}
                                />
                              </p>
                            </div>
                          )}
                        </>
                      );
                    }

                    // 5e.tools format fallback
                    if (selectedSpell.entries) {
                      return selectedSpell.entries.map((entry, idx) => {
                        if (typeof entry === "string") {
                          // Clean up 5e.tools markup and make dice clickable
                          const cleanText = entry.replace(
                            /\{@[^}]+\}/g,
                            (match) => {
                              // Extract text from markup like {@damage 2d6} or {@spell fireball}
                              const textMatch = match.match(
                                /\{@\w+ ([^}|]+)(?:\|[^}]+)?\}/
                              );
                              return textMatch ? textMatch[1] : match;
                            }
                          );

                          return (
                            <p key={idx} className="leading-relaxed">
                              <RollableText
                                text={cleanText}
                                onRoll={() => setShowSpellModal(false)}
                              />
                            </p>
                          );
                        } else if (
                          entry.type === "entries" &&
                          entry.name === "At Higher Levels"
                        ) {
                          return (
                            <div
                              key={idx}
                              className="bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800 rounded p-3"
                            >
                              <div className="font-semibold text-purple-900 dark:text-purple-300 mb-1">
                                At Higher Levels
                              </div>
                              {entry.entries.map((subEntry, subIdx) => (
                                <p key={subIdx} className="text-sm">
                                  <RollableText
                                    text={
                                      typeof subEntry === "string"
                                        ? subEntry.replace(
                                            /\{@[^}]+\}/g,
                                            (m) =>
                                              m.match(
                                                /\{@\w+ ([^}|]+)(?:\|[^}]+)?\}/
                                              )?.[1] || m
                                          )
                                        : ""
                                    }
                                    onRoll={() => setShowSpellModal(false)}
                                  />
                                </p>
                              ))}
                            </div>
                          );
                        }
                        return null;
                      });
                    }

                    return null;
                  })()}
                </div>
              </div>

              {/* Classes that can cast this spell */}
              {selectedSpell.classes && selectedSpell.classes.fromClassList && (
                <div className="border-t border-slate-200 dark:border-slate-700 pt-4">
                  <span className="font-semibold text-purple-800 dark:text-purple-300">
                    Classes:
                  </span>
                  <span className="ml-2 text-slate-700 dark:text-slate-300">
                    {selectedSpell.classes.fromClassList
                      .map((c) => c.name)
                      .join(", ")}
                  </span>
                </div>
              )}

              {/* Source */}
              <div className="text-xs text-slate-500 dark:text-slate-400 border-t border-slate-200 dark:border-slate-700 pt-2">
                Source: {selectedSpell.source}
                {selectedSpell.page && ` p${selectedSpell.page}`}
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Dice Context Menu */}
      {diceContextMenu.show && (
        <>
          {/* Backdrop to close menu on click */}
          <div
            className="fixed inset-0 z-[60]"
            onClick={() =>
              setDiceContextMenu({ ...diceContextMenu, show: false })
            }
            onContextMenu={(e) => {
              e.preventDefault();
              setDiceContextMenu({ ...diceContextMenu, show: false });
            }}
          />
          {/* Menu */}
          <div
            className="fixed z-[61] bg-white dark:bg-slate-800 rounded-lg shadow-2xl border-2 border-blue-500 dark:border-blue-700 p-2 min-w-[180px]"
            style={{
              left: `${diceContextMenu.x}px`,
              top: `${diceContextMenu.y}px`,
            }}
          >
            {diceContextMenu.type === "d20" ? (
              // d20 rolls: Advantage, Normal, Disadvantage
              <>
                <div className="text-xs font-semibold text-slate-600 dark:text-slate-400 px-2 py-1">
                  d20 Roll
                </div>
                <button
                  className="w-full text-left px-3 py-2 text-sm hover:bg-green-50 dark:hover:bg-green-900/20 text-green-700 dark:text-green-300 rounded transition-colors"
                  onClick={() => {
                    const creatureName = selectedCombatant?.name || "Unknown";
                    rollDice({
                      notation: diceContextMenu.notation,
                      rollMode: "advantage",
                      label: diceContextMenu.label || diceContextMenu.notation,
                      character: creatureName,
                    });
                    if (diceContextMenu.onRoll) diceContextMenu.onRoll();
                    setDiceContextMenu({ ...diceContextMenu, show: false });
                  }}
                >
                  ðŸŽ²ðŸŽ² Advantage
                </button>
                <button
                  className="w-full text-left px-3 py-2 text-sm hover:bg-blue-50 dark:hover:bg-blue-900/20 text-blue-700 dark:text-blue-300 rounded transition-colors"
                  onClick={() => {
                    const creatureName = selectedCombatant?.name || "Unknown";
                    rollDice({
                      notation: diceContextMenu.notation,
                      rollMode: "normal",
                      label: diceContextMenu.label || diceContextMenu.notation,
                      character: creatureName,
                    });
                    if (diceContextMenu.onRoll) diceContextMenu.onRoll();
                    setDiceContextMenu({ ...diceContextMenu, show: false });
                  }}
                >
                  ðŸŽ² Normal
                </button>
                <button
                  className="w-full text-left px-3 py-2 text-sm hover:bg-red-50 dark:hover:bg-red-900/20 text-red-700 dark:text-red-300 rounded transition-colors"
                  onClick={() => {
                    const creatureName = selectedCombatant?.name || "Unknown";
                    rollDice({
                      notation: diceContextMenu.notation,
                      rollMode: "disadvantage",
                      label: diceContextMenu.label || diceContextMenu.notation,
                      character: creatureName,
                    });
                    if (diceContextMenu.onRoll) diceContextMenu.onRoll();
                    setDiceContextMenu({ ...diceContextMenu, show: false });
                  }}
                >
                  ðŸŽ²ðŸŽ² Disadvantage
                </button>
              </>
            ) : (
              // Damage rolls: Normal, Critical Hit
              <>
                <div className="text-xs font-semibold text-slate-600 dark:text-slate-400 px-2 py-1">
                  Damage Roll
                </div>
                <button
                  className="w-full text-left px-3 py-2 text-sm hover:bg-blue-50 dark:hover:bg-blue-900/20 text-blue-700 dark:text-blue-300 rounded transition-colors"
                  onClick={() => {
                    const creatureName = selectedCombatant?.name || "Unknown";
                    rollDice({
                      notation: diceContextMenu.notation,
                      rollMode: "normal",
                      label: diceContextMenu.label || diceContextMenu.notation,
                      character: creatureName,
                    });
                    if (diceContextMenu.onRoll) diceContextMenu.onRoll();
                    setDiceContextMenu({ ...diceContextMenu, show: false });
                  }}
                >
                  ðŸŽ² Normal
                </button>
                <button
                  className="w-full text-left px-3 py-2 text-sm hover:bg-orange-50 dark:hover:bg-orange-900/20 text-orange-700 dark:text-orange-300 rounded transition-colors"
                  onClick={() => {
                    const creatureName = selectedCombatant?.name || "Unknown";
                    rollDice({
                      notation: diceContextMenu.notation,
                      rollMode: "normal",
                      critical: true,
                      label: diceContextMenu.label || diceContextMenu.notation,
                      character: creatureName,
                    });
                    if (diceContextMenu.onRoll) diceContextMenu.onRoll();
                    setDiceContextMenu({ ...diceContextMenu, show: false });
                  }}
                >
                  ðŸ’¥ Critical Hit
                </button>
              </>
            )}
          </div>
        </>
      )}

      {/* Fullscreen Creature Manager */}
      {showCreatureManager && (
        <FullscreenCreatureManager
          creature={editingCreature}
          initialTab={creatureManagerInitialTab}
          initialSearch={creatureManagerInitialSearch}
          campaigns={campaigns}
          onClose={() => {
            setShowCreatureManager(false);
            setEditingCreature(null);
            setCreatureManagerInitialTab("browse");
            setCreatureManagerInitialSearch("");
          }}
          onSave={(creature) => {
            setShowCreatureManager(false);
            setEditingCreature(null);
            setCreatureManagerInitialTab("browse");
            setCreatureManagerInitialSearch("");
          }}
          onAddMonster={addMonster}
        />
      )}

      {/* Player Screen Button */}
      {enc && combatMode && (
        <button
          className="fixed top-20 right-6 btn bg-gradient-to-r from-indigo-500 to-blue-600 text-white hover:from-indigo-600 hover:to-blue-700 border-none shadow-lg z-10"
          onClick={() => {
            // Use absolute URL to ensure it works both locally and online
            const baseUrl = window.location.origin + window.location.pathname.replace('index.html', '');
            const url = `${baseUrl}player.html?encounter=${encodeURIComponent(
              currentId
            )}`;
            window.open(
              url,
              "PlayerScreen",
              "width=800,height=600,menubar=no,toolbar=no,location=no"
            );
          }}
          title="Open Player Screen"
        >
          ðŸ“º Player Screen
        </button>
      )}

      {/* Custom Modals */}
      {modal}

      {/* Campaign Manager Modal */}
      {showCampaignManager && (
        <CampaignManager onClose={() => setShowCampaignManager(false)} />
      )}
    </div>
  );
}

function FullscreenCreatureManager({
  creature,
  initialTab,
  initialSearch,
  onClose,
  onSave,
  onAddMonster,
  campaigns = [],
}) {
  const [tab, setTab] = useState(creature ? "form" : initialTab || "browse");
  const [list, setList] = useState([]);
  const [q, setQ] = useState(initialSearch || "");
  const [selectedTags, setSelectedTags] = useState([]);
  const [form, setForm] = useState(
    creature
      ? normalizeCreatureForForm(creature)
      : {
          name: "",
          ac: "",
          hp: "",
          cr: "",
          type: "",
          speed: "",
          initiativeMod: "",
          source: "homebrew",
          tags: [],
          imageUrl: "",
        }
  );
  const [jsonText, setJsonText] = useState(
    '[\n  { "name": "Bandit Captain", "ac": 15, "hp": 65, "cr": 2, "type": "humanoid (any)", "speed": "30 ft.", "initiativeMod": 2 }\n]'
  );
  const [ddbText, setDdbText] = useState(
    "Goblin\nSmall humanoid (goblinoid), neutral evil\nArmor Class 15 (leather armor, shield)\nHit Points 7 (2d6)\nSpeed 30 ft.\nChallenge 1/4 (50 XP)"
  );
  const [sourceTooltip, setSourceTooltip] = useState({
    source: null,
    fullName: null,
    x: 0,
    y: 0,
  });

  useEffect(() => {
    apiGet(`/api/monsters?search=${encodeURIComponent(q)}`)
      .then((r) => r.json())
      .then(setList);
  }, [q]);

  async function saveCreature() {
    const payload = {
      ...form,
      name: form.name.trim(),
      ac: numberOr(form.ac, undefined),
      hp: numberOr(form.hp, undefined),
      cr: form.cr === "" ? undefined : Number(form.cr),
      type: form.type || undefined,
      speed: form.speed || undefined,
      initiativeMod: numberOr(form.initiativeMod, undefined),
      tags: form.tags || [],
      campaignIds: form.campaignIds || [],
      imageUrl: form.imageUrl || undefined,
    };
    if (!payload.name) {
      await alert("Name fehlt");
      return;
    }
    const r = await apiPost("/api/monsters", payload);
    if (!r.ok) {
      await alert("Fehler beim Speichern");
      return;
    }
    onSave(await r.json());
  }

  async function saveAsNew() {
    const name = await prompt(
      "Neuer Name fÃ¼r die Kreatur:",
      form.name + " (Copy)"
    );
    if (!name) return;
    const payload = {
      ...form,
      id: undefined, // Force new ID
      name: name.trim(),
      ac: numberOr(form.ac, undefined),
      hp: numberOr(form.hp, undefined),
      cr: form.cr === "" ? undefined : Number(form.cr),
      type: form.type || undefined,
      speed: form.speed || undefined,
      initiativeMod: numberOr(form.initiativeMod, undefined),
      tags: form.tags || [],
    };
    const r = await apiPost("/api/monsters", payload);
    if (!r.ok) {
      await alert("Fehler beim Speichern");
      return;
    }
    onSave(await r.json());
  }

  async function importJSON() {
    let arr;
    try {
      arr = JSON.parse(jsonText);
    } catch {
      await alert("UngÃ¼ltiges JSON");
      return;
    }
    const payload = Array.isArray(arr) ? arr : arr?.monsters;
    if (!Array.isArray(payload)) {
      await alert("Erwarte Array oder { monsters: [...] }");
      return;
    }
    const r = await apiPost("/api/monsters/bulk", payload);
    const out = await r.json();
    await alert(`Import OK â€“ erstellt: ${out.created}`);
    setQ("");
  }

  async function importDDB() {
    const r = await apiPost("/api/monsters/import/ddb", { text: ddbText });
    const out = await r.json();
    if (out.error) {
      await alert(out.error);
      return;
    }
    await alert(`DDB-Import OK â€“ erstellt: ${out.created}`);
    setQ("");
  }

  async function deleteCreature(id) {
    if (!(await confirm("Kreatur wirklich lÃ¶schen?"))) return;
    await apiDelete(`/api/monsters/${encodeURIComponent(id)}`);
    setQ(q + " "); // Refresh list
  }

  function loadCreature(monster) {
    const normalized = normalizeCreatureForForm(monster);
    setForm(normalized);
    setTab("form");
  }

  return (
    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
      <div className="creature-manager-container bg-white dark:bg-slate-800 rounded-2xl shadow-2xl w-full max-w-6xl max-h-[90vh] overflow-hidden flex flex-col">
        {/* Header */}
        <div className="bg-gradient-to-r from-green-500 to-emerald-600 text-white p-6 flex items-center justify-between">
          <div>
            <h2 className="text-3xl font-bold">ðŸ‰ Creature Manager</h2>
            <p className="text-green-100 text-sm mt-1">
              Create, edit, and manage all creatures
            </p>
          </div>
          <button
            className="w-10 h-10 rounded-full bg-white/20 hover:bg-white/30 dark:bg-slate-700/50 dark:hover:bg-slate-600/50 flex items-center justify-center text-2xl transition-colors"
            onClick={onClose}
          >
            âœ•
          </button>
        </div>

        {/* Tabs */}
        <div className="border-b border-slate-200 dark:border-slate-700 flex gap-1 px-6 bg-slate-50 dark:bg-slate-900">
          {["form", "json", "ddb", "browse", "players"].map((t) => (
            <button
              key={t}
              className={`px-4 py-3 font-medium transition-colors ${
                tab === t
                  ? "text-green-700 dark:text-green-400 border-b-2 border-green-600 bg-white dark:bg-slate-800"
                  : "text-slate-600 dark:text-slate-400 hover:text-slate-900 dark:hover:text-slate-200"
              }`}
              onClick={() => setTab(t)}
            >
              {t === "form" && "ðŸ“ Edit Creature"}
              {t === "json" && "ðŸ“„ JSON Import"}
              {t === "ddb" && "ðŸŽ² D&D Beyond"}
              {t === "browse" && "ðŸ“š Browse All"}
              {t === "players" && "ðŸ‘¥ Player Characters"}
            </button>
          ))}
        </div>

        {/* Content */}
        <div className="flex-1 overflow-y-auto p-6">
          {tab === "form" && (
            <div className="max-w-6xl mx-auto space-y-6">
              {/* Basic Info */}
              <div className="card">
                <h3 className="h2">Basic Information</h3>
                <div className="grid md:grid-cols-3 gap-4">
                  <div>
                    <label className="lbl mb-1 block">Name *</label>
                    <input
                      className="input"
                      placeholder="Creature name"
                      value={form.name || ""}
                      onChange={(e) =>
                        setForm({ ...form, name: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Type</label>
                    <input
                      className="input"
                      placeholder="e.g. humanoid, beast"
                      value={form.type || ""}
                      onChange={(e) =>
                        setForm({ ...form, type: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Size</label>
                    <select
                      className="input"
                      value={form.size || "Medium"}
                      onChange={(e) =>
                        setForm({ ...form, size: e.target.value })
                      }
                    >
                      <option value="Tiny">Tiny</option>
                      <option value="Small">Small</option>
                      <option value="Medium">Medium</option>
                      <option value="Large">Large</option>
                      <option value="Huge">Huge</option>
                      <option value="Gargantuan">Gargantuan</option>
                    </select>
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Alignment</label>
                    <input
                      className="input"
                      placeholder="e.g. neutral evil"
                      value={form.alignment || ""}
                      onChange={(e) =>
                        setForm({ ...form, alignment: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Armor Class</label>
                    <input
                      type="number"
                      className="input"
                      placeholder="AC"
                      value={form.ac || ""}
                      onChange={(e) => setForm({ ...form, ac: e.target.value })}
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Hit Points</label>
                    <input
                      type="number"
                      className="input"
                      placeholder="HP"
                      value={form.hp || ""}
                      onChange={(e) => setForm({ ...form, hp: e.target.value })}
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Hit Dice</label>
                    <input
                      className="input"
                      placeholder="e.g. 8d10+16"
                      value={form.hitDice || ""}
                      onChange={(e) =>
                        setForm({ ...form, hitDice: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Challenge Rating</label>
                    <input
                      type="number"
                      step="0.125"
                      className="input"
                      placeholder="CR"
                      value={form.cr || ""}
                      onChange={(e) => setForm({ ...form, cr: e.target.value })}
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">
                      Initiative Modifier
                    </label>
                    <input
                      type="number"
                      className="input"
                      placeholder="+0"
                      value={form.initiativeMod || ""}
                      onChange={(e) =>
                        setForm({ ...form, initiativeMod: e.target.value })
                      }
                    />
                  </div>
                  <div className="md:col-span-3">
                    <label className="lbl mb-1 block">
                      Bild URL (Token/Avatar)
                    </label>
                    <input
                      type="url"
                      className="input"
                      placeholder="https://example.com/image.png"
                      value={form.imageUrl || ""}
                      onChange={(e) =>
                        setForm({ ...form, imageUrl: e.target.value })
                      }
                    />
                    <p className="text-xs text-slate-500 dark:text-slate-400 mt-1">
                      Optionale URL zu einem Bild (wird im Player Screen angezeigt)
                    </p>
                  </div>
                </div>
              </div>

              {/* Ability Scores */}
              <div className="card">
                <h3 className="h2">Ability Scores</h3>
                <div className="grid grid-cols-6 gap-3">
                  {["str", "dex", "con", "int", "wis", "cha"].map((ability) => (
                    <div key={ability}>
                      <label className="lbl mb-1 block text-center uppercase">
                        {ability}
                      </label>
                      <input
                        type="number"
                        className="input text-center"
                        placeholder="10"
                        value={form[ability] || ""}
                        onChange={(e) =>
                          setForm({ ...form, [ability]: e.target.value })
                        }
                      />
                    </div>
                  ))}
                </div>
              </div>

              {/* Speed */}
              <div className="card">
                <h3 className="h2">Speed</h3>
                <div className="grid md:grid-cols-5 gap-4">
                  <div>
                    <label className="lbl mb-1 block">Walk</label>
                    <input
                      className="input"
                      placeholder="30 ft."
                      value={form.speed || ""}
                      onChange={(e) =>
                        setForm({ ...form, speed: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Fly</label>
                    <input
                      className="input"
                      placeholder="60 ft."
                      value={form.fly || ""}
                      onChange={(e) =>
                        setForm({ ...form, fly: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Swim</label>
                    <input
                      className="input"
                      placeholder="30 ft."
                      value={form.swim || ""}
                      onChange={(e) =>
                        setForm({ ...form, swim: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Climb</label>
                    <input
                      className="input"
                      placeholder="30 ft."
                      value={form.climb || ""}
                      onChange={(e) =>
                        setForm({ ...form, climb: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Burrow</label>
                    <input
                      className="input"
                      placeholder="20 ft."
                      value={form.burrow || ""}
                      onChange={(e) =>
                        setForm({ ...form, burrow: e.target.value })
                      }
                    />
                  </div>
                </div>
              </div>

              {/* Senses & Languages */}
              <div className="card">
                <h3 className="h2">Senses & Languages</h3>
                <div className="grid md:grid-cols-2 gap-4">
                  <div>
                    <label className="lbl mb-1 block">Senses</label>
                    <input
                      className="input"
                      placeholder="e.g. darkvision 60 ft., passive Perception 12"
                      value={form.senses || ""}
                      onChange={(e) =>
                        setForm({ ...form, senses: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Languages</label>
                    <input
                      className="input"
                      placeholder="e.g. Common, Draconic"
                      value={form.languages || ""}
                      onChange={(e) =>
                        setForm({ ...form, languages: e.target.value })
                      }
                    />
                  </div>
                </div>
              </div>

              {/* Defenses */}
              <div className="card">
                <h3 className="h2">Defenses</h3>
                <div className="space-y-3">
                  <div>
                    <label className="lbl mb-1 block">
                      Damage Vulnerabilities
                    </label>
                    <input
                      className="input"
                      placeholder="e.g. fire, cold"
                      value={form.vulnerabilities || ""}
                      onChange={(e) =>
                        setForm({ ...form, vulnerabilities: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Damage Resistances</label>
                    <input
                      className="input"
                      placeholder="e.g. bludgeoning from nonmagical attacks"
                      value={form.resistances || ""}
                      onChange={(e) =>
                        setForm({ ...form, resistances: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Damage Immunities</label>
                    <input
                      className="input"
                      placeholder="e.g. poison, psychic"
                      value={form.immunities || ""}
                      onChange={(e) =>
                        setForm({ ...form, immunities: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">
                      Condition Immunities
                    </label>
                    <input
                      className="input"
                      placeholder="e.g. charmed, frightened, paralyzed"
                      value={form.conditionImmunities || ""}
                      onChange={(e) =>
                        setForm({
                          ...form,
                          conditionImmunities: e.target.value,
                        })
                      }
                    />
                  </div>
                </div>
              </div>

              {/* Actions & Abilities */}
              <div className="card">
                <h3 className="h2">Traits, Actions & Abilities</h3>
                <div className="space-y-4">
                  <div>
                    <label className="lbl mb-1 block">Traits</label>
                    <textarea
                      className="input h-32 font-mono text-sm resize-y"
                      placeholder="Special traits and passive abilities (one per line or JSON format)"
                      value={form.traits || ""}
                      onChange={(e) =>
                        setForm({ ...form, traits: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Actions</label>
                    <textarea
                      className="input h-32 font-mono text-sm resize-y"
                      placeholder="Actions the creature can take (one per line or JSON format)"
                      value={form.actions || ""}
                      onChange={(e) =>
                        setForm({ ...form, actions: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Bonus Actions</label>
                    <textarea
                      className="input h-24 font-mono text-sm resize-y"
                      placeholder="Bonus actions (one per line or JSON format)"
                      value={form.bonusActions || ""}
                      onChange={(e) =>
                        setForm({ ...form, bonusActions: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Reactions</label>
                    <textarea
                      className="input h-24 font-mono text-sm resize-y"
                      placeholder="Reactions (one per line or JSON format)"
                      value={form.reactions || ""}
                      onChange={(e) =>
                        setForm({ ...form, reactions: e.target.value })
                      }
                    />
                  </div>
                  <div>
                    <label className="lbl mb-1 block">Legendary Actions</label>
                    <textarea
                      className="input h-24 font-mono text-sm resize-y"
                      placeholder="Legendary actions (one per line or JSON format)"
                      value={form.legendaryActions || ""}
                      onChange={(e) =>
                        setForm({ ...form, legendaryActions: e.target.value })
                      }
                    />
                  </div>
                </div>
              </div>

              {/* Tags */}
              <div className="card">
                <h3 className="h2">Tags</h3>
                <TagInput
                  value={form.tags || []}
                  onChange={(tags) => setForm({ ...form, tags })}
                />
                <p className="text-xs text-slate-500 mt-1">
                  Add tags to organize and filter creatures (terrain,
                  difficulty, adventure, etc.)
                </p>
              </div>

              {/* Campaigns */}
              <div className="card">
                <h3 className="h2">Kampagnen</h3>
                {campaigns.length === 0 ? (
                  <p className="text-sm text-gray-500">Keine Kampagnen verfÃ¼gbar</p>
                ) : (
                  <div className="space-y-2">
                    {campaigns.map(campaign => (
                      <label key={campaign.id} className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          checked={(form.campaignIds || []).includes(campaign.id)}
                          onChange={e => {
                            const campaignIds = form.campaignIds || [];
                            if (e.target.checked) {
                              setForm({ ...form, campaignIds: [...campaignIds, campaign.id] });
                            } else {
                              setForm({ ...form, campaignIds: campaignIds.filter(id => id !== campaign.id) });
                            }
                          }}
                          className="rounded"
                        />
                        <span className="text-sm">{campaign.name}</span>
                      </label>
                    ))}
                  </div>
                )}
                <p className="text-xs text-slate-500 mt-2">
                  Weise dieses Monster einer oder mehreren Kampagnen zu
                </p>
              </div>
            </div>
          )}

          {tab === "json" && (
            <div className="max-w-4xl mx-auto space-y-4">
              <label className="lbl">
                Array of monsters or {"{ monsters:[...] }"}
              </label>
              <textarea
                className="input h-96 font-mono text-sm"
                value={jsonText}
                onChange={(e) => setJsonText(e.target.value)}
              />
              <button
                className="btn bg-green-600 text-white hover:bg-green-700 border-green-600"
                onClick={importJSON}
              >
                Import JSON
              </button>
            </div>
          )}

          {tab === "ddb" && (
            <div className="max-w-4xl mx-auto space-y-4">
              <label className="lbl">Paste D&D Beyond statblock (text)</label>
              <textarea
                className="input h-96 font-mono text-sm"
                value={ddbText}
                onChange={(e) => setDdbText(e.target.value)}
              />
              <div className="text-sm text-slate-600">
                Note: Parser extracts Name/Type/AC/HP/Speed/CR only.
              </div>
              <button
                className="btn bg-green-600 text-white hover:bg-green-700 border-green-600"
                onClick={importDDB}
              >
                Import D&D Beyond
              </button>
            </div>
          )}

          {tab === "browse" && (
            <div className="max-w-4xl mx-auto space-y-4">
              <input
                className="input w-full"
                placeholder="Search creatures..."
                value={q}
                onChange={(e) => setQ(e.target.value)}
              />

              {/* Tag Filter */}
              <div className="card bg-slate-50 dark:bg-slate-900/50">
                <label className="text-sm font-semibold text-slate-700 dark:text-slate-300 mb-2 block">
                  Filter by Tags
                </label>
                <TagInput value={selectedTags} onChange={setSelectedTags} />
              </div>

              <div className="grid gap-2">
                {list
                  .filter((m) => {
                    // Filter by selected tags
                    if (selectedTags.length === 0) return true;
                    const monsterTags = m.tags || [];
                    return selectedTags.every((tag) =>
                      monsterTags.includes(tag)
                    );
                  })
                  .map((m, mIndex) => {
                    const displayHP =
                      typeof m.hp === "object" && m.hp !== null
                        ? m.hp.average
                        : m.hp;
                    const displayAC =
                      typeof m.ac === "object" && m.ac !== null
                        ? m.ac.value
                        : m.ac;
                    return (
                      <div
                        key={`${m.id}-${mIndex}`}
                        className="card flex items-start justify-between gap-4"
                      >
                        <div className="flex-1 min-w-0">
                          <div className="font-semibold text-lg">{m.name}</div>
                          <div className="text-sm text-slate-600 mb-2">
                            CR {m.cr ?? "â€”"} Â· AC {displayAC ?? "â€”"} Â· HP{" "}
                            {displayHP ?? "â€”"} Â·{" "}
                            {typeof m.type === "string"
                              ? m.type
                              : typeof m.type?.type === "string"
                              ? m.type.type
                              : m.type?.type?.choose
                              ? `${m.type.type.choose.join(" or ")}`
                              : ""}
                          </div>
                          {/* Display tags */}
                          {m.tags && m.tags.length > 0 && (
                            <div className="flex flex-wrap gap-1">
                              {m.tags.map((tag, tagIndex) => {
                                // Handle case where tag might be an object or string
                                const tagValue =
                                  typeof tag === "string"
                                    ? tag
                                    : tag?.type || JSON.stringify(tag);
                                const tagColors = {
                                  Underdark:
                                    "bg-purple-100 text-purple-800 border-purple-200",
                                  Forest:
                                    "bg-green-100 text-green-800 border-green-200",
                                  Mountain:
                                    "bg-slate-100 text-slate-800 border-slate-200",
                                  Desert:
                                    "bg-yellow-100 text-yellow-800 border-yellow-200",
                                  Swamp:
                                    "bg-emerald-100 text-emerald-800 border-emerald-200",
                                  Coastal:
                                    "bg-blue-100 text-blue-800 border-blue-200",
                                  Urban:
                                    "bg-gray-100 text-gray-800 border-gray-200",
                                  Dungeon:
                                    "bg-stone-100 text-stone-800 border-stone-200",
                                  Planar:
                                    "bg-indigo-100 text-indigo-800 border-indigo-200",
                                  Boss: "bg-red-100 text-red-800 border-red-200",
                                  Minion:
                                    "bg-slate-100 text-slate-600 border-slate-200",
                                  Elite:
                                    "bg-orange-100 text-orange-800 border-orange-200",
                                };
                                return (
                                  <span
                                    key={`${m.id}-tag-${tagIndex}`}
                                    className={`inline-block px-2 py-0.5 rounded-full text-xs font-medium border ${
                                      tagColors[tagValue] ||
                                      "bg-slate-100 text-slate-800 border-slate-200"
                                    }`}
                                  >
                                    {tagValue}
                                  </span>
                                );
                              })}
                            </div>
                          )}
                        </div>
                        <div className="flex gap-2 flex-shrink-0">
                          <button
                            className="btn"
                            onClick={() => loadCreature(m)}
                          >
                            âœï¸ Edit
                          </button>
                          <button
                            className="btn hover:bg-red-100 hover:text-red-700"
                            onClick={() => deleteCreature(m.id)}
                          >
                            ðŸ—‘ï¸
                          </button>
                        </div>
                      </div>
                    );
                  })}
              </div>
            </div>
          )}

          {tab === "players" && (
            <PlayerCharacterTab
              apiGet={apiGet}
              apiPost={apiPost}
              apiDelete={apiDelete}
              alert={alert}
              confirm={confirm}
              campaigns={campaigns}
              onAddToEncounter={(pc) => {
                // Konvertiere PC zu Monster-Format und fÃ¼ge zum Encounter hinzu
                const monsterFormat = {
                  name: pc.name,
                  ac: pc.ac,
                  hp: pc.hp,
                  initiativeMod: pc.initiativeMod || 0,
                  speed: pc.speed || "30 ft.",
                  isPC: true,
                  source: pc.source || 'player-character',
                };
                // Verwende die addMonster Funktion aus dem App-Scope
                if (onAddMonster) {
                  onAddMonster(monsterFormat);
                  onClose();
                }
              }}
            />
          )}
        </div>

        {/* Footer with action buttons */}
        {tab === "form" && (
          <div className="border-t border-slate-200 dark:border-slate-700 p-6 bg-slate-50 dark:bg-slate-900 flex items-center justify-between gap-4">
            <button className="btn" onClick={onClose}>
              Cancel
            </button>
            <div className="flex gap-2">
              {form.id && (
                <button
                  className="btn bg-blue-500 text-white hover:bg-blue-600 border-blue-500"
                  onClick={saveAsNew}
                >
                  ðŸ’¾ Save as New
                </button>
              )}
              <button
                className="btn bg-green-600 text-white hover:bg-green-700 border-green-600"
                onClick={saveCreature}
              >
                âœ… {form.id ? "Update" : "Create"} Creature
              </button>
            </div>
          </div>
        )}
      </div>

      {/* Source Tooltip (Hover) */}
      {sourceTooltip.source && (
        <div
          className="fixed z-50 bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-slate-800 dark:to-slate-900 rounded-xl shadow-2xl border-2 border-blue-400 dark:border-blue-600 p-5 pointer-events-none"
          style={{
            left: `${sourceTooltip.x}px`,
            top: `${sourceTooltip.y}px`,
            width: "320px",
          }}
        >
          <div className="space-y-3">
            <div className="flex items-center gap-3">
              <div className="w-10 h-10 rounded-full bg-blue-500 dark:bg-blue-600 flex items-center justify-center flex-shrink-0">
                <svg
                  className="w-6 h-6 text-white"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
              </div>
              <div className="flex-1">
                <div className="text-xs font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wider mb-1">
                  Source Book
                </div>
                <div className="text-lg font-bold text-blue-900 dark:text-blue-100 leading-tight">
                  {sourceTooltip.fullName || sourceTooltip.source}
                </div>
              </div>
            </div>

            <div className="border-t-2 border-blue-200 dark:border-blue-800 pt-3">
              <div className="flex items-center gap-2 text-sm">
                <span className="px-2.5 py-1 bg-blue-200 dark:bg-blue-900/60 text-blue-800 dark:text-blue-300 rounded-md font-mono font-semibold">
                  {sourceTooltip.source}
                </span>
                <span className="text-blue-600 dark:text-blue-400 text-xs">
                  abbreviation
                </span>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

function TagInput({ value, onChange }) {
  const [input, setInput] = useState("");
  const [showSuggestions, setShowSuggestions] = useState(false);
  const commonTags = [
    "Underdark",
    "Forest",
    "Mountain",
    "Desert",
    "Swamp",
    "Coastal",
    "Urban",
    "Dungeon",
    "Planar",
    "Boss",
    "Minion",
    "Elite",
    "Aberration",
    "Beast",
    "Celestial",
    "Construct",
    "Dragon",
    "Elemental",
    "Fey",
    "Fiend",
    "Giant",
    "Humanoid",
    "Monstrosity",
    "Ooze",
    "Plant",
    "Undead",
  ];
  const tags = value || [];
  const filtered = commonTags.filter(
    (t) => !tags.includes(t) && t.toLowerCase().includes(input.toLowerCase())
  );

  const addTag = (tag) => {
    onChange([...tags, tag]);
    setInput("");
    setShowSuggestions(false);
  };

  const removeTag = (tag) => {
    onChange(tags.filter((t) => t !== tag));
  };

  const tagColors = {
    // Terrain
    Underdark: "bg-purple-100 text-purple-800 border-purple-200",
    Forest: "bg-green-100 text-green-800 border-green-200",
    Mountain: "bg-slate-100 text-slate-800 border-slate-200",
    Desert: "bg-yellow-100 text-yellow-800 border-yellow-200",
    Swamp: "bg-emerald-100 text-emerald-800 border-emerald-200",
    Coastal: "bg-blue-100 text-blue-800 border-blue-200",
    Urban: "bg-gray-100 text-gray-800 border-gray-200",
    Dungeon: "bg-stone-100 text-stone-800 border-stone-200",
    Planar: "bg-indigo-100 text-indigo-800 border-indigo-200",
    // Difficulty
    Boss: "bg-red-100 text-red-800 border-red-200",
    Minion: "bg-slate-100 text-slate-600 border-slate-200",
    Elite: "bg-orange-100 text-orange-800 border-orange-200",
  };

  return (
    <div className="space-y-2">
      <div className="flex flex-wrap gap-2">
        {tags.map((tag, index) => {
          // Handle case where tag might be an object or string
          const tagValue =
            typeof tag === "string" ? tag : tag?.type || JSON.stringify(tag);
          return (
            <span
              key={`tag-${index}-${tagValue}`}
              className={`inline-flex items-center gap-1 px-3 py-1 rounded-full text-sm font-medium border ${
                tagColors[tagValue] ||
                "bg-slate-100 text-slate-800 border-slate-200 dark:bg-slate-700 dark:text-slate-200 dark:border-slate-600"
              }`}
            >
              {tagValue}
              <button
                onClick={() => removeTag(tag)}
                className="ml-1 w-4 h-4 flex items-center justify-center rounded-full hover:bg-black/10 dark:hover:bg-white/10 transition-colors"
                title="Remove tag"
              >
                Ã—
              </button>
            </span>
          );
        })}
      </div>
      <div className="relative">
        <input
          className="input w-full"
          placeholder="Add tag (press Enter or comma to add)..."
          value={input}
          onChange={(e) => {
            setInput(e.target.value);
            setShowSuggestions(true);
          }}
          onFocus={() => setShowSuggestions(true)}
          onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
          onKeyDown={(e) => {
            if ((e.key === "Enter" || e.key === ",") && input.trim()) {
              addTag(input.trim());
              e.preventDefault();
            }
          }}
        />
        {showSuggestions && (filtered.length > 0 || input.trim()) && (
          <div className="absolute z-50 w-full mt-1 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl shadow-lg max-h-48 overflow-auto">
            {filtered.map((tag) => (
              <button
                key={tag}
                className="w-full text-left px-3 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 text-sm flex items-center gap-2"
                onClick={() => addTag(tag)}
              >
                <span
                  className={`inline-block px-2 py-0.5 rounded-full text-xs font-medium border ${
                    tagColors[tag] ||
                    "bg-slate-100 text-slate-800 border-slate-200"
                  }`}
                >
                  {tag}
                </span>
              </button>
            ))}
            {input.trim() &&
              !commonTags.some(
                (t) => t.toLowerCase() === input.toLowerCase()
              ) && (
                <button
                  className="w-full text-left px-3 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 text-sm border-t border-slate-200 dark:border-slate-700"
                  onClick={() => addTag(input.trim())}
                >
                  <span className="text-blue-600 dark:text-blue-400">
                    + Create "{input.trim()}"
                  </span>
                </button>
              )}
          </div>
        )}
      </div>
    </div>
  );
}

function ConditionAutocomplete({ value, onChange }) {
  const [input, setInput] = useState("");
  const [showSuggestions, setShowSuggestions] = useState(false);
  const commonConditions = [
    "Blinded",
    "Charmed",
    "Deafened",
    "Frightened",
    "Grappled",
    "Incapacitated",
    "Invisible",
    "Paralyzed",
    "Petrified",
    "Poisoned",
    "Prone",
    "Restrained",
    "Stunned",
    "Unconscious",
  ];
  const conditions = value || [];
  const filtered = commonConditions.filter(
    (c) =>
      !conditions.includes(c) && c.toLowerCase().includes(input.toLowerCase())
  );

  const addCondition = (cond) => {
    onChange([...conditions, cond]);
    setInput("");
    setShowSuggestions(false);
  };

  const removeCondition = (cond) => {
    onChange(conditions.filter((c) => c !== cond));
  };

  return (
    <div className="space-y-2">
      <div className="flex flex-wrap gap-2">
        {conditions.map((cond) => (
          <span
            key={cond}
            className="inline-flex items-center gap-1 px-3 py-1 bg-amber-100 text-amber-800 rounded-full text-sm font-medium"
          >
            {cond}
            <button
              onClick={() => removeCondition(cond)}
              className="hover:text-amber-900"
            >
              Ã—
            </button>
          </span>
        ))}
      </div>
      <div className="relative">
        <input
          className="input w-full"
          placeholder="Add condition..."
          value={input}
          onChange={(e) => {
            setInput(e.target.value);
            setShowSuggestions(true);
          }}
          onFocus={() => setShowSuggestions(true)}
          onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && input.trim()) {
              addCondition(input.trim());
              e.preventDefault();
            }
          }}
        />
        {showSuggestions && filtered.length > 0 && (
          <div className="absolute z-50 w-full mt-1 bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl shadow-lg max-h-48 overflow-auto">
            {filtered.map((cond) => (
              <button
                key={cond}
                className="w-full text-left px-3 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 text-sm dark:text-slate-200"
                onClick={() => addCondition(cond)}
              >
                {cond}
              </button>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}

function InlineEdit({
  value,
  onChange,
  className = "",
  type = "text",
  onBlur,
}) {
  const [isEditing, setIsEditing] = useState(false);
  const [tempValue, setTempValue] = useState(value);
  const inputRef = React.useRef(null);

  React.useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  const handleSave = () => {
    onChange(tempValue);
    setIsEditing(false);
    if (onBlur) onBlur();
  };

  if (!isEditing) {
    return (
      <div
        className={`cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700 rounded px-2 py-1 transition-colors ${className}`}
        onClick={() => {
          setTempValue(value);
          setIsEditing(true);
        }}
      >
        {value || "â€”"}
      </div>
    );
  }

  return (
    <input
      ref={inputRef}
      type={type}
      className={`border-2 border-blue-400 dark:border-blue-500 rounded-lg px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white dark:bg-slate-700 dark:text-slate-100 ${className}`}
      value={tempValue}
      onChange={(e) =>
        setTempValue(
          type === "number" ? Number(e.target.value) : e.target.value
        )
      }
      onBlur={handleSave}
      onKeyDown={(e) => {
        if (e.key === "Enter") handleSave();
        if (e.key === "Escape") {
          setTempValue(value);
          setIsEditing(false);
        }
      }}
    />
  );
}

function QuickHPInput({
  currentHP,
  maxHP,
  tempHP,
  onHeal,
  onDamage,
  onSetHP,
  onClose,
}) {
  const [input, setInput] = useState("");
  const inputRef = React.useRef(null);

  React.useEffect(() => {
    if (inputRef.current) inputRef.current.focus();
  }, []);

  const handleSubmit = () => {
    const val = input.trim();
    if (!val) return;

    if (val.startsWith("+")) {
      // Healing
      const amount = parseInt(val.substring(1)) || 0;
      onHeal(amount);
    } else if (val.startsWith("-")) {
      // Damage
      const amount = parseInt(val.substring(1)) || 0;
      onDamage(amount);
    } else {
      // Absolute value
      const amount = parseInt(val) || 0;
      onSetHP(amount);
    }
    onClose();
  };

  return (
    <div className="absolute inset-0 bg-white dark:bg-slate-800 z-10 flex items-center justify-center rounded-xl shadow-lg border-2 border-blue-500 dark:border-blue-400">
      <div className="text-center space-y-3 p-4">
        <div className="text-sm text-slate-600 dark:text-slate-300">
          HP: <span className="font-bold">{currentHP}</span> / {maxHP}
          {tempHP > 0 && (
            <span className="text-cyan-600 dark:text-cyan-400 ml-2">
              +{tempHP} temp
            </span>
          )}
        </div>
        <input
          ref={inputRef}
          type="text"
          className="input w-32 text-center text-lg font-bold"
          placeholder="+10 oder -5"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") handleSubmit();
            if (e.key === "Escape") onClose();
          }}
          onBlur={onClose}
        />
        <div className="text-xs text-slate-500 dark:text-slate-400">
          +10 (heal) | -5 (dmg) | 20 (set)
        </div>
      </div>
    </div>
  );
}

function CombatantRow({
  c,
  idx,
  active,
  onChange,
  onSelect,
  isSelected,
  onDamage,
  allPlayers = [],
}) {
  const [open, setOpen] = useState(false);
  const [showHPInput, setShowHPInput] = useState(false);

  // Special rendering for Lair Action markers
  if (c.isLairAction) {
    return (
      <div
        className={`card relative overflow-hidden cursor-pointer transition-all ${
          active ? "ring-2 ring-red-500 shadow-lg bg-red-50 dark:bg-red-900/30" : "bg-red-50/50 dark:bg-red-900/10"
        } ${isSelected ? "ring-2 ring-purple-400" : ""}`}
        onClick={(e) => {
          if (!e.defaultPrevented) onSelect();
        }}
      >
        <div className="flex items-center gap-3 py-3">
          <div className="w-8 h-8 flex items-center justify-center bg-red-200 dark:bg-red-800 rounded-full font-bold text-sm text-red-900 dark:text-red-200">
            {idx + 1}
          </div>
          <div className="flex-1 font-semibold text-lg text-red-900 dark:text-red-300">
            {c.name}
          </div>
          <div className="flex items-center gap-1 text-red-700 dark:text-red-400">
            <span className="text-xs">Init</span>
            <span className="w-16 text-center font-bold">{c.initiative}</span>
          </div>
          <div className="px-3 py-1 bg-red-200 dark:bg-red-800 text-red-900 dark:text-red-200 rounded-full text-xs font-semibold">
            DM Only
          </div>
        </div>
      </div>
    );
  }

  const hpPercent =
    c.baseHP > 0 ? Math.max(0, Math.min(100, (c.hp / c.baseHP) * 100)) : 100;
  const hpColor =
    hpPercent > 60
      ? "bg-green-500"
      : hpPercent > 30
      ? "bg-yellow-500"
      : "bg-red-500";

  return (
    <div
      className={`card relative overflow-hidden cursor-pointer transition-all ${
        active ? "ring-2 ring-blue-500 shadow-lg" : ""
      } ${isSelected ? "ring-2 ring-purple-400" : ""} ${
        c.concentration ? "border-l-4 border-l-purple-500" : ""
      }`}
      onClick={(e) => {
        if (!e.defaultPrevented) onSelect();
      }}
    >
      {showHPInput && (
        <QuickHPInput
          currentHP={c.hp ?? 0}
          maxHP={c.baseHP}
          tempHP={c.tempHP ?? 0}
          onHeal={(amount) => {
            onChange({ hp: Math.min(c.baseHP, c.hp + amount) });
            setShowHPInput(false);
          }}
          onDamage={(amount) => {
            onDamage(amount);
            setShowHPInput(false);
          }}
          onSetHP={(hp) => {
            onChange({ hp: Math.max(0, Math.min(c.baseHP, hp)) });
            setShowHPInput(false);
          }}
          onClose={() => setShowHPInput(false)}
        />
      )}

      {c.concentration && (
        <div className="absolute top-2 right-2 px-2 py-1 bg-purple-100 dark:bg-purple-900/50 text-purple-700 dark:text-purple-300 text-xs font-semibold rounded-full flex items-center gap-1 pointer-events-none z-5">
          <span className="w-2 h-2 bg-purple-500 dark:bg-purple-400 rounded-full animate-pulse"></span>
          Concentrating
        </div>
      )}

      <div className="space-y-2">
        {/* First Row: Index, Name, Stats */}
        <div className="flex items-center gap-3 flex-wrap">
          <div className="w-8 h-8 flex items-center justify-center bg-slate-200 dark:bg-slate-700 rounded-full font-bold text-sm dark:text-slate-200">
            {idx + 1}
          </div>

          <div className="flex-1 min-w-[200px] flex items-center gap-2">
            <InlineEdit
              value={c.name}
              onChange={(name) => onChange({ name })}
              className="font-semibold text-lg dark:text-slate-100"
            />
            {c.sidekickOf && (
              <span className="px-2 py-0.5 bg-cyan-100 dark:bg-cyan-900/30 text-cyan-700 dark:text-cyan-300 rounded text-xs font-semibold">
                ðŸ¤ Sidekick
              </span>
            )}
          </div>

          <div className="flex items-center gap-1">
            <span className="text-xs text-slate-500 dark:text-slate-400">
              Init
            </span>
            <InlineEdit
              value={c.initiative ?? 0}
              onChange={(initiative) => onChange({ initiative })}
              type="number"
              className="w-16 text-center font-bold text-blue-600 dark:text-blue-400"
            />
          </div>

          <div className="flex items-center gap-1">
            <span className="text-xs text-slate-500 dark:text-slate-400">AC</span>
            <InlineEdit
              value={c.ac ?? 0}
              onChange={(ac) => onChange({ ac })}
              type="number"
              className="w-16 text-center dark:text-slate-100"
            />
          </div>

          <div className="flex items-center gap-2">
            <span className="text-xs text-slate-500 dark:text-slate-400">HP</span>
            <div className="flex items-center gap-1">
              <InlineEdit
                value={`${c.hp ?? 0}${c.tempHP > 0 ? `+${c.tempHP}` : ''}`}
                onChange={(val) => {
                  if (!val) return;
                  onChange(applyHPChange(c, val));
                }}
                type="text"
                className="w-24 text-center font-bold dark:text-slate-100"
                placeholder="+10/-5"
              />
              <span className="text-slate-400 dark:text-slate-500">/</span>
              <InlineEdit
                value={c.baseHP}
                onChange={(baseHP) => onChange({ baseHP })}
                type="number"
                className="w-16 text-center text-slate-600 dark:text-slate-300 font-medium"
              />
            </div>
          </div>
        </div>

        {/* Second Row: Action Buttons */}
        <div className="flex items-center gap-2 pl-11">
          <button
            className={`px-3 py-1.5 rounded-full text-sm font-medium transition-all ${
              c.concentration
                ? "bg-purple-500 dark:bg-purple-600 text-white"
                : "bg-slate-100 dark:bg-slate-700 text-slate-600 dark:text-slate-300 hover:bg-purple-100 dark:hover:bg-purple-900/30"
            }`}
            onClick={(e) => {
              e.stopPropagation();
              onChange({ concentration: !c.concentration });
            }}
          >
            {c.concentration ? "âš¡ Concentrating" : "Concentration"}
          </button>

          <button
            className={`p-2 rounded-lg text-lg transition-all ${
              c.visibleToPlayers !== false
                ? "bg-blue-100 dark:bg-blue-900/30 text-blue-600 dark:text-blue-400"
                : "bg-slate-100 dark:bg-slate-700 text-slate-400 dark:text-slate-500"
            }`}
            onClick={(e) => {
              e.stopPropagation();
              onChange({ visibleToPlayers: c.visibleToPlayers === false });
            }}
            title={c.visibleToPlayers !== false ? "Visible to players" : "Hidden from players"}
          >
            {c.visibleToPlayers !== false ? "ðŸ‘ï¸" : "ðŸ‘ï¸â€ðŸ—¨ï¸"}
          </button>

          <button
            className="btn ml-auto"
            onClick={(e) => {
              e.stopPropagation();
              setOpen((v) => !v);
            }}
          >
            {open ? "â–²" : "â–¼"}
          </button>
        </div>
      </div>

      {/* HP Bar */}
      <div className="mt-3 h-2 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
        <div
          className={`h-full ${hpColor} transition-all duration-300`}
          style={{ width: `${hpPercent}%` }}
        ></div>
      </div>

      {/* Conditions Display */}
      {c.conditions && c.conditions.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {c.conditions.map((cond) => (
            <span
              key={cond}
              className="px-2 py-0.5 bg-amber-100 text-amber-800 rounded-full text-xs font-medium"
            >
              {cond}
            </span>
          ))}
        </div>
      )}

      {open && (
        <div className="mt-4 pt-4 border-t grid md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <div>
              <label className="lbl mb-1 block">Notizen</label>
              <textarea
                className="input h-24 resize-none"
                value={c.notes || ""}
                onChange={(e) => onChange({ notes: e.target.value })}
                placeholder="Notizen hinzufÃ¼gen..."
              />
            </div>

            <div>
              <label className="lbl mb-1 block">Sidekick zuweisen</label>
              <select
                className="input w-full"
                value={c.sidekickOf || ''}
                onChange={(e) => onChange({ sidekickOf: e.target.value || null })}
              >
                <option value="">Kein Sidekick</option>
                {allPlayers.map(p => (
                  <option key={p.id} value={p.id}>{p.name}</option>
                ))}
              </select>
              <p className="text-xs text-slate-500 dark:text-slate-400 mt-1">
                Sidekicks teilen die Initiative mit ihrem zugeordneten Spieler
              </p>
            </div>

            <div>
              <label className="lbl mb-1 block">Conditions</label>
              <ConditionAutocomplete
                value={c.conditions || []}
                onChange={(conditions) => onChange({ conditions })}
              />
            </div>
          </div>

          <div>
            <h4 className="font-semibold mb-2">Spell Slots</h4>
            <SlotEditor
              slots={c.spellSlots || {}}
              onChange={(slots) => onChange({ spellSlots: slots })}
            />
          </div>
        </div>
      )}
    </div>
  );
}

function MonsterBrowser({ onPick, onEdit, disabled, RollableText, combatMode, selectedCombatant }) {
  const [q, setQ] = useState("");
  const [list, setList] = useState([]);
  const [allMonsters, setAllMonsters] = useState([]);
  const [sourceTooltip, setSourceTooltip] = useState({
    source: null,
    fullName: null,
    x: 0,
    y: 0,
  });

  // Filter states - Multi-select arrays for Type, Size, Source
  const [crMin, setCrMin] = useState("");
  const [crMax, setCrMax] = useState("");
  const [selectedTypes, setSelectedTypes] = useState([]);
  const [selectedSources, setSelectedSources] = useState([]);
  const [selectedSizes, setSelectedSizes] = useState([]);

  // Refs for Select2
  const typeSelectRef = useRef(null);
  const sizeSelectRef = useRef(null);
  const sourceSelectRef = useRef(null);

  // Load all monsters once for filtering
  useEffect(() => {
    apiGet("/api/monsters?search=")
      .then((r) => r.json())
      .then(setAllMonsters);
  }, []);

  // Get unique values for dropdowns - MUST be defined before useEffect that uses them
  const availableTypes = useMemo(() => {
    const types = new Set();
    allMonsters.forEach((m) => {
      if (m.type) {
        const typeStr = typeof m.type === "string" ? m.type : m.type?.type;
        if (typeStr && typeof typeStr === "string") {
          // Capitalize first letter
          const capitalized =
            typeStr.charAt(0).toUpperCase() + typeStr.slice(1);
          types.add(capitalized);
        }
      }
    });
    return Array.from(types).sort();
  }, [allMonsters]);

  const availableSources = useMemo(() => {
    const sources = new Set();
    allMonsters.forEach((m) => {
      // Check source, src, and meta.source fields
      const src = m.source || m.src || m.meta?.source;
      if (src) sources.add(src);
    });
    return Array.from(sources).sort();
  }, [allMonsters]);

  const availableSizes = useMemo(() => {
    const sizes = new Set();
    allMonsters.forEach((m) => {
      if (m.size) sizes.add(m.size);
    });
    return Array.from(sizes).sort();
  }, [allMonsters]);

  // Initialize Select2 for multi-select dropdowns
  useEffect(() => {
    const $ = window.$;

    // Initialize Type select
    if (typeSelectRef.current && availableTypes.length > 0) {
      const $select = $(typeSelectRef.current);
      $select.select2({
        placeholder: "Alle Typen auswÃ¤hlen...",
        allowClear: true,
        width: "100%",
        multiple: true,
      });

      $select.on("change", function () {
        const values = $(this).val() || [];
        setSelectedTypes(values);
      });
    }

    // Initialize Size select
    if (sizeSelectRef.current && availableSizes.length > 0) {
      const $select = $(sizeSelectRef.current);
      $select.select2({
        placeholder: "Alle GrÃ¶ÃŸen auswÃ¤hlen...",
        allowClear: true,
        width: "100%",
        multiple: true,
      });

      $select.on("change", function () {
        const values = $(this).val() || [];
        setSelectedSizes(values);
      });
    }

    // Initialize Source select with custom matcher for full name search
    if (sourceSelectRef.current && availableSources.length > 0) {
      const $select = $(sourceSelectRef.current);
      $select.select2({
        placeholder: "Alle Quellen auswÃ¤hlen...",
        allowClear: true,
        width: "100%",
        multiple: true,
        matcher: function (params, data) {
          // If there are no search terms, return all data
          if ($.trim(params.term) === "") {
            return data;
          }

          // Search in both the source abbreviation and full name
          const searchTerm = params.term.toLowerCase();
          const sourceAbbrev = data.id.toLowerCase();
          const sourceFullName = (
            SOURCE_VOCAB[data.id]?.name || ""
          ).toLowerCase();
          const displayText = data.text?.toLowerCase() || "";

          // Match against abbreviation, full name, or display text
          if (
            sourceAbbrev.includes(searchTerm) ||
            sourceFullName.includes(searchTerm) ||
            displayText.includes(searchTerm)
          ) {
            return data;
          }

          // Return null if the term should not be displayed
          return null;
        },
      });

      $select.on("change", function () {
        const values = $(this).val() || [];
        setSelectedSources(values);
      });
    }

    // Cleanup
    return () => {
      try {
        if (typeSelectRef.current && $(typeSelectRef.current).data("select2")) {
          $(typeSelectRef.current).select2("destroy");
        }
        if (sizeSelectRef.current && $(sizeSelectRef.current).data("select2")) {
          $(sizeSelectRef.current).select2("destroy");
        }
        if (
          sourceSelectRef.current &&
          $(sourceSelectRef.current).data("select2")
        ) {
          $(sourceSelectRef.current).select2("destroy");
        }
      } catch (e) {
        // Ignore cleanup errors
      }
    };
  }, [availableTypes, availableSizes, availableSources]);

  // Apply all filters
  useEffect(() => {
    const t = setTimeout(() => {
      let filtered = [...allMonsters];

      // Name/Type/Source search - also searches full source names
      if (q) {
        const lowerQ = q.toLowerCase();
        filtered = filtered.filter((m) => {
          const name = m.name?.toLowerCase() || "";
          const typeStr =
            typeof m.type === "string" ? m.type : m.type?.type || "";
          const typeStrLower = String(typeStr).toLowerCase();

          // Get source and its full name
          const sourceAbbrev = m.source || m.src || m.meta?.source;
          const sourceAbbrevLower = sourceAbbrev?.toLowerCase() || "";
          const sourceFullName = sourceAbbrev
            ? (SOURCE_VOCAB[sourceAbbrev]?.name || "").toLowerCase()
            : "";

          return (
            name.includes(lowerQ) ||
            typeStrLower.includes(lowerQ) ||
            sourceAbbrevLower.includes(lowerQ) ||
            sourceFullName.includes(lowerQ)
          );
        });
      }

      // CR filter
      if (crMin !== "") {
        const min = parseFloat(crMin);
        filtered = filtered.filter((m) => {
          const cr = m.cr !== undefined ? parseFloat(m.cr) : -1;
          return cr >= min;
        });
      }
      if (crMax !== "") {
        const max = parseFloat(crMax);
        filtered = filtered.filter((m) => {
          const cr = m.cr !== undefined ? parseFloat(m.cr) : -1;
          return cr <= max;
        });
      }

      // Type filter - Multi-select
      if (selectedTypes.length > 0) {
        filtered = filtered.filter((m) => {
          const typeStr = typeof m.type === "string" ? m.type : m.type?.type;
          if (!typeStr) return false;
          const capitalized =
            typeStr.charAt(0).toUpperCase() + typeStr.slice(1);
          return selectedTypes.includes(capitalized);
        });
      }

      // Source filter - Multi-select
      if (selectedSources.length > 0) {
        filtered = filtered.filter((m) => {
          const src = m.source || m.src || m.meta?.source;
          return selectedSources.includes(src);
        });
      }

      // Size filter - Multi-select
      if (selectedSizes.length > 0) {
        filtered = filtered.filter((m) => selectedSizes.includes(m.size));
      }

      setList(filtered.slice(0, 100)); // Limit to 100 results
    }, 200);
    return () => clearTimeout(t);
  }, [
    q,
    crMin,
    crMax,
    selectedTypes,
    selectedSources,
    selectedSizes,
    allMonsters,
  ]);

  const clearFilters = () => {
    setQ("");
    setCrMin("");
    setCrMax("");
    setSelectedTypes([]);
    setSelectedSources([]);
    setSelectedSizes([]);

    // Clear Select2 selections
    const $ = window.$;
    if (typeSelectRef.current)
      $(typeSelectRef.current).val(null).trigger("change");
    if (sizeSelectRef.current)
      $(sizeSelectRef.current).val(null).trigger("change");
    if (sourceSelectRef.current)
      $(sourceSelectRef.current).val(null).trigger("change");
  };

  const hasActiveFilters =
    q ||
    crMin ||
    crMax ||
    selectedTypes.length > 0 ||
    selectedSources.length > 0 ||
    selectedSizes.length > 0;

  return (
    <div>
      {/* Header */}
      <div className="mb-4">
        <h3 className="text-lg font-bold text-green-900 dark:text-green-300 mb-1">
          Browse Monsters
        </h3>
        <p className="text-xs text-slate-600 dark:text-slate-400">
          Suche und filtere aus Ã¼ber 2000 Monstern
        </p>
      </div>

      {/* Search Bar */}
      <div className="mb-4">
        <div className="relative">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <svg
              className="h-5 w-5 text-slate-400"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
              />
            </svg>
          </div>
          <input
            className="input w-full pl-10 pr-4 py-3 text-base"
            placeholder="Nach Name oder Typ suchen..."
            value={q}
            onChange={(e) => setQ(e.target.value)}
          />
        </div>
      </div>

      {/* Filter Panel - Always Visible */}
      <div className="mb-4 p-4 bg-gradient-to-br from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 rounded-xl shadow-sm border border-green-200 dark:border-green-800">
        <div className="flex items-center justify-between mb-3">
          <h4 className="text-sm font-bold text-green-800 dark:text-green-300 flex items-center gap-2">
            <svg
              className="w-4 h-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.293A1 1 0 013 6.586V4z"
              />
            </svg>
            Filter
          </h4>
          {hasActiveFilters && (
            <button
              onClick={clearFilters}
              className="text-xs px-3 py-1 rounded-full bg-red-100 dark:bg-red-900/40 text-red-700 dark:text-red-300 hover:bg-red-200 dark:hover:bg-red-900/60 transition-all font-semibold shadow-sm"
            >
              âœ• ZurÃ¼cksetzen
            </button>
          )}
        </div>

        <div className="space-y-3">
          {/* CR Range */}
          <div className="grid grid-cols-2 gap-3">
            <div>
              <label className="text-xs text-green-800 dark:text-green-300 font-semibold block mb-1.5">
                CR Min
              </label>
              <input
                type="number"
                className="input w-full text-sm"
                placeholder="0"
                value={crMin}
                onChange={(e) => setCrMin(e.target.value)}
                min="0"
                step="0.125"
              />
            </div>
            <div>
              <label className="text-xs text-green-800 dark:text-green-300 font-semibold block mb-1.5">
                CR Max
              </label>
              <input
                type="number"
                className="input w-full text-sm"
                placeholder="30"
                value={crMax}
                onChange={(e) => setCrMax(e.target.value)}
                min="0"
                step="0.125"
              />
            </div>
          </div>

          {/* Type, Size, Source in one row - Multi-select with Select2 */}
          <div className="grid grid-cols-3 gap-3">
            {/* Type */}
            <div>
              <label className="text-xs text-green-800 dark:text-green-300 font-semibold block mb-1.5">
                Typ (Multi)
              </label>
              <select
                ref={typeSelectRef}
                className="input w-full text-sm"
                multiple
                value={selectedTypes}
                onChange={() => {}} // Handled by Select2
              >
                {availableTypes.map((type) => (
                  <option key={type} value={type}>
                    {type}
                  </option>
                ))}
              </select>
            </div>

            {/* Size */}
            <div>
              <label className="text-xs text-green-800 dark:text-green-300 font-semibold block mb-1.5">
                GrÃ¶ÃŸe (Multi)
              </label>
              <select
                ref={sizeSelectRef}
                className="input w-full text-sm"
                multiple
                value={selectedSizes}
                onChange={() => {}} // Handled by Select2
              >
                {availableSizes.map((size) => (
                  <option key={size} value={size}>
                    {size}
                  </option>
                ))}
              </select>
            </div>

            {/* Source */}
            <div>
              <label className="text-xs text-green-800 dark:text-green-300 font-semibold block mb-1.5">
                Quelle (Multi)
              </label>
              <select
                ref={sourceSelectRef}
                className="input w-full text-sm"
                multiple
                value={selectedSources}
                onChange={() => {}} // Handled by Select2
              >
                {availableSources.map((source) => (
                  <option key={source} value={source}>
                    {source} - {SOURCE_VOCAB[source]?.name || source}
                  </option>
                ))}
              </select>
            </div>
          </div>
        </div>
      </div>

      {/* Results count */}
      {list.length > 0 && (
        <div className="text-xs text-green-700 dark:text-green-300 mb-1 px-1">
          {list.length} {list.length === 100 ? "+ " : ""}Ergebnis
          {list.length !== 1 ? "se" : ""}
        </div>
      )}

      <ul className="divide-y divide-green-100 dark:divide-green-800 bg-white dark:bg-slate-800 rounded-xl border border-green-200 dark:border-green-800 max-h-64 overflow-auto">
        {list.length === 0 ? (
          <li className="py-3 px-3 text-sm text-slate-500 dark:text-slate-400 text-center">
            {hasActiveFilters
              ? "Keine Monster gefunden"
              : "Tippe um zu suchen oder Ã¶ffne Filter..."}
          </li>
        ) : (
          list.map((m, index) => {
            const displayHP =
              typeof m.hp === "object" && m.hp !== null ? m.hp.average : m.hp;
            const displayAC =
              typeof m.ac === "object" && m.ac !== null ? m.ac.value : m.ac;
            return (
              <li
                key={`${m.id}-${index}`}
                className="py-2 px-3 flex items-center justify-between gap-2 hover:bg-green-50 dark:hover:bg-green-900/20 transition-colors cursor-pointer"
                onClick={() => onEdit && onEdit(m)}
              >
                <div className="min-w-0 flex-1">
                  <div className="font-medium text-sm truncate dark:text-slate-200">
                    {m.name}
                  </div>
                  <div className="flex items-center justify-between gap-2">
                    <div className="text-xs text-slate-600 dark:text-slate-400">
                      CR {m.cr ?? "â€”"} Â· AC {displayAC ?? "â€”"} Â· HP{" "}
                      {displayHP ?? "â€”"}
                    </div>
                    {(m.source || m.src || m.meta?.source) && (
                      <span
                        className={`px-2 py-0.5 rounded-full text-xs font-semibold flex-shrink-0 border ${getSourceColorClasses(
                          m.source || m.src || m.meta?.source
                        )}`}
                        onMouseEnter={(e) => {
                          const sourceValue =
                            m.source || m.src || m.meta?.source;
                          const sourceData = SOURCE_VOCAB[sourceValue];
                          const fullName = sourceData?.name || sourceValue;
                          const rect = e.currentTarget.getBoundingClientRect();
                          const tooltipWidth = 320;
                          const x = rect.left - tooltipWidth - 15;
                          const y = rect.top;
                          setSourceTooltip({
                            source: sourceValue,
                            fullName,
                            x,
                            y,
                          });
                        }}
                        onMouseMove={(e) => {
                          if (sourceTooltip.source) {
                            const rect =
                              e.currentTarget.getBoundingClientRect();
                            const tooltipWidth = 320;
                            const x = rect.left - tooltipWidth - 15;
                            const y = rect.top;
                            setSourceTooltip((prev) => ({ ...prev, x, y }));
                          }
                        }}
                        onMouseLeave={() => {
                          setSourceTooltip({
                            source: null,
                            fullName: null,
                            x: 0,
                            y: 0,
                          });
                        }}
                      >
                        {m.source || m.src || m.meta?.source}
                      </span>
                    )}
                  </div>
                </div>
                <button
                  className="btn text-xs px-2 py-1 flex-shrink-0 font-bold relative"
                  style={{ top: "-2px" }}
                  disabled={disabled}
                  onClick={(e) => {
                    e.stopPropagation();
                    onPick(m);
                  }}
                >
                  +
                </button>
              </li>
            );
          })
        )}
      </ul>

      {/* Source Tooltip (Hover) */}
      {sourceTooltip.source && (
        <div
          className="fixed z-50 bg-gradient-to-br from-blue-50 to-indigo-50 dark:from-slate-800 dark:to-slate-900 rounded-xl shadow-2xl border-2 border-blue-400 dark:border-blue-600 p-5 pointer-events-none"
          style={{
            left: `${sourceTooltip.x}px`,
            top: `${sourceTooltip.y}px`,
            width: "320px",
          }}
        >
          <div className="space-y-3">
            <div className="flex items-center gap-3">
              <div className="bg-blue-500 dark:bg-blue-600 text-white rounded-lg p-2">
                <svg
                  className="w-6 h-6"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"
                  />
                </svg>
              </div>
              <div>
                <div className="text-xs font-semibold text-blue-600 dark:text-blue-400 uppercase tracking-wider">
                  Source
                </div>
                <div className="text-sm font-bold text-slate-900 dark:text-slate-100">
                  {sourceTooltip.source}
                </div>
              </div>
            </div>
            <div className="border-t border-blue-200 dark:border-blue-700 pt-2">
              <div className="text-base font-semibold text-slate-800 dark:text-slate-200">
                {sourceTooltip.fullName}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

      {/* Statblock Sidebar - Overlay */}
      {selectedCombatant && !selectedCombatant.isLair && (
        <div
          className="fixed top-0 right-0 h-full w-96 bg-white dark:bg-slate-800 shadow-2xl transform transition-transform duration-300 ease-in-out z-30 translate-x-0 overflow-y-auto"
        >
          <div className="h-full flex flex-col">
            {/* Header */}
            <div className="sticky top-0 bg-white dark:bg-slate-800 border-b border-slate-200 dark:border-slate-700 p-4 z-10">
              <button
                className="absolute top-4 right-4 w-8 h-8 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700 flex items-center justify-center text-slate-600 dark:text-slate-400"
                onClick={() => setSelectedCombatantId(null)}
              >
                âœ•
              </button>
              <h2 className="text-xl font-bold mb-1 dark:text-slate-100 pr-10">{selectedCombatant.name}</h2>
              <p className="text-sm text-slate-600 dark:text-slate-400">
                {selectedCombatant.size} {selectedCombatant.type?.type || selectedCombatant.type || 'creature'}
                {selectedCombatant.type?.tags && ` (${selectedCombatant.type.tags.join(', ')})`}
              </p>
            </div>

            {/* Content */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
              {/* Quick Stats */}
              <div className="grid grid-cols-3 gap-2">
                <div className="card p-2">
                  <div className="lbl text-xs">Initiative</div>
                  <div className="text-lg font-bold dark:text-slate-100">
                    {selectedCombatant.initiative !== undefined ? selectedCombatant.initiative : 'â€”'}
                  </div>
                </div>
                <div className="card p-2">
                  <div className="lbl text-xs">AC</div>
                  <div className="text-lg font-bold dark:text-slate-100">
                    {Array.isArray(selectedCombatant.ac) ? selectedCombatant.ac[0]?.value : selectedCombatant.ac}
                  </div>
                </div>
                <div className="card p-2">
                  <div className="lbl text-xs">HP</div>
                  <div className="text-lg font-bold dark:text-slate-100">
                    {selectedCombatant.hp || 0}/{selectedCombatant.baseHP || 0}
                  </div>
                </div>
              </div>

              {/* HP Management */}
              <div className="card space-y-2">
                <div className="lbl">HP Management</div>
                <div className="flex gap-2">
                  <input
                    type="number"
                    className="input flex-1 text-sm"
                    placeholder="Amount"
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        const val = e.target.value;
                        if (val) {
                          updateCombatant(selectedCombatant.id, applyHPChange(selectedCombatant, val));
                          e.target.value = '';
                        }
                      }
                    }}
                  />
                </div>
                <div className="grid grid-cols-3 gap-1">
                  <button
                    className="btn text-xs py-1"
                    onClick={() => {
                      const input = document.querySelector('.input[placeholder="Amount"]');
                      if (input && input.value) {
                        updateCombatant(selectedCombatant.id, applyHPChange(selectedCombatant, input.value));
                        input.value = '';
                      }
                    }}
                  >
                    Heal
                  </button>
                  <button
                    className="btn text-xs py-1"
                    onClick={() => {
                      const input = document.querySelector('.input[placeholder="Amount"]');
                      if (input && input.value) {
                        updateCombatant(selectedCombatant.id, applyHPChange(selectedCombatant, `-${input.value}`));
                        input.value = '';
                      }
                    }}
                  >
                    Damage
                  </button>
                  <button
                    className="btn text-xs py-1"
                    onClick={() => {
                      const input = document.querySelector('.input[placeholder="Amount"]');
                      if (input && input.value) {
                        updateCombatant(selectedCombatant.id, applyHPChange(selectedCombatant, `=${input.value}`));
                        input.value = '';
                      }
                    }}
                  >
                    Set
                  </button>
                </div>
                {selectedCombatant.tempHP > 0 && (
                  <div className="text-xs text-blue-600 dark:text-blue-400">
                    Temp HP: {selectedCombatant.tempHP}
                  </div>
                )}
              </div>

              {/* Death Saves (if HP is 0) */}
              {selectedCombatant.hp === 0 && (
                <div className="card space-y-2">
                  <div className="lbl">Death Saves</div>
                  <div className="flex justify-between">
                    <div>
                      <div className="text-xs text-green-600 dark:text-green-400">Successes</div>
                      <div className="flex gap-1">
                        {[1, 2, 3].map(i => (
                          <button
                            key={i}
                            className={`w-6 h-6 rounded border ${
                              (selectedCombatant.deathSaves?.successes || 0) >= i
                                ? 'bg-green-500 border-green-600'
                                : 'border-slate-300 dark:border-slate-600'
                            }`}
                            onClick={() => {
                              const current = selectedCombatant.deathSaves?.successes || 0;
                              updateCombatant(selectedCombatant.id, {
                                deathSaves: {
                                  ...selectedCombatant.deathSaves,
                                  successes: current >= i ? i - 1 : i
                                }
                              });
                            }}
                          />
                        ))}
                      </div>
                    </div>
                    <div>
                      <div className="text-xs text-red-600 dark:text-red-400">Failures</div>
                      <div className="flex gap-1">
                        {[1, 2, 3].map(i => (
                          <button
                            key={i}
                            className={`w-6 h-6 rounded border ${
                              (selectedCombatant.deathSaves?.failures || 0) >= i
                                ? 'bg-red-500 border-red-600'
                                : 'border-slate-300 dark:border-slate-600'
                            }`}
                            onClick={() => {
                              const current = selectedCombatant.deathSaves?.failures || 0;
                              updateCombatant(selectedCombatant.id, {
                                deathSaves: {
                                  ...selectedCombatant.deathSaves,
                                  failures: current >= i ? i - 1 : i
                                }
                              });
                            }}
                          />
                        ))}
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Concentration */}
              {selectedCombatant.concentratingOn && (
                <div className="card bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800">
                  <div className="flex justify-between items-center">
                    <div>
                      <div className="text-xs font-semibold text-purple-700 dark:text-purple-300">Concentrating</div>
                      <div className="text-sm dark:text-slate-200">{selectedCombatant.concentratingOn}</div>
                    </div>
                    <button
                      className="btn text-xs"
                      onClick={() => updateCombatant(selectedCombatant.id, { concentratingOn: null })}
                    >
                      End
                    </button>
                  </div>
                </div>
              )}

              {/* Conditions */}
              {selectedCombatant.conditions && selectedCombatant.conditions.length > 0 && (
                <div className="card space-y-1">
                  <div className="lbl">Conditions</div>
                  <div className="flex flex-wrap gap-1">
                    {selectedCombatant.conditions.map((cond, idx) => (
                      <span
                        key={idx}
                        className="px-2 py-1 text-xs bg-orange-100 dark:bg-orange-900/30 text-orange-800 dark:text-orange-300 rounded"
                      >
                        {cond}
                      </span>
                    ))}
                  </div>
                </div>
              )}

              {/* Basic Info */}
              <div className="card space-y-1 text-sm">
                <div className="flex justify-between">
                  <span className="lbl">CR</span>
                  <span className="dark:text-slate-200">{selectedCombatant.cr || 'â€”'}</span>
                </div>
                {selectedCombatant.alignment && (
                  <div className="flex justify-between">
                    <span className="lbl">Alignment</span>
                    <span className="dark:text-slate-200">{selectedCombatant.alignment}</span>
                  </div>
                )}
                {selectedCombatant.speed && (
                  <div className="flex justify-between">
                    <span className="lbl">Speed</span>
                    <span className="dark:text-slate-200">
                      {Object.entries(selectedCombatant.speed).map(([k, v]) => `${k} ${v}ft`).join(', ')}
                    </span>
                  </div>
                )}
              </div>

              {/* Ability Scores */}
              {selectedCombatant.abilities && (
                <div className="card">
                  <div className="lbl mb-2">Abilities</div>
                  <div className="grid grid-cols-6 gap-1 text-center">
                    {['str', 'dex', 'con', 'int', 'wis', 'cha'].map(ability => {
                      const score = selectedCombatant.abilities?.[ability] || 10;
                      const mod = Math.floor((score - 10) / 2);
                      return (
                        <div key={ability} className="text-xs">
                          <div className="font-semibold uppercase text-slate-600 dark:text-slate-400">{ability}</div>
                          <div className="font-bold dark:text-slate-100">{score}</div>
                          <div className="text-slate-500 dark:text-slate-500">
                            {mod >= 0 ? '+' : ''}{mod}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}

              {/* Saving Throws */}
              {selectedCombatant.savingThrows && Object.keys(selectedCombatant.savingThrows).length > 0 && (
                <div className="card text-sm">
                  <div className="lbl mb-1">Saving Throws</div>
                  <div className="dark:text-slate-200">
                    {Object.entries(selectedCombatant.savingThrows).map(([ability, bonus]) => (
                      <span key={ability} className="mr-2">
                        {ability.toUpperCase()} {bonus >= 0 ? '+' : ''}{bonus}
                      </span>
                    ))}
                  </div>
                </div>
              )}

              {/* Skills */}
              {selectedCombatant.skills && Object.keys(selectedCombatant.skills).length > 0 && (
                <div className="card text-sm">
                  <div className="lbl mb-1">Skills</div>
                  <div className="dark:text-slate-200">
                    {Object.entries(selectedCombatant.skills).map(([skill, bonus]) => (
                      <span key={skill} className="mr-2 capitalize">
                        {skill} {bonus >= 0 ? '+' : ''}{bonus}
                      </span>
                    ))}
                  </div>
                </div>
              )}

              {/* Resistances/Immunities */}
              {(selectedCombatant.damageResistances?.length > 0 ||
                selectedCombatant.damageImmunities?.length > 0 ||
                selectedCombatant.damageVulnerabilities?.length > 0) && (
                <div className="card text-sm space-y-1">
                  {selectedCombatant.damageVulnerabilities?.length > 0 && (
                    <div>
                      <span className="lbl">Vulnerabilities: </span>
                      <span className="dark:text-slate-200">{selectedCombatant.damageVulnerabilities.join(', ')}</span>
                    </div>
                  )}
                  {selectedCombatant.damageResistances?.length > 0 && (
                    <div>
                      <span className="lbl">Resistances: </span>
                      <span className="dark:text-slate-200">{selectedCombatant.damageResistances.join(', ')}</span>
                    </div>
                  )}
                  {selectedCombatant.damageImmunities?.length > 0 && (
                    <div>
                      <span className="lbl">Immunities: </span>
                      <span className="dark:text-slate-200">{selectedCombatant.damageImmunities.join(', ')}</span>
                    </div>
                  )}
                </div>
              )}

              {/* Traits */}
              {selectedCombatant.traits && selectedCombatant.traits.length > 0 && (
                <div className="space-y-2">
                  <div className="h2">Traits</div>
                  {selectedCombatant.traits.map((trait, idx) => (
                    <div key={idx} className="card text-sm">
                      <div className="font-semibold mb-1 dark:text-slate-200">{trait.name}</div>
                      <div className="text-slate-700 dark:text-slate-300">
                        <RollableText text={trait.desc} onRoll={handleRoll} />
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Actions */}
              {selectedCombatant.actions && selectedCombatant.actions.length > 0 && (
                <div className="space-y-2">
                  <div className="h2">Actions</div>
                  {selectedCombatant.actions.map((action, idx) => (
                    <div key={idx} className="card text-sm">
                      <div className="font-semibold mb-1 dark:text-slate-200">{action.name}</div>
                      <div className="text-slate-700 dark:text-slate-300">
                        <RollableText text={action.desc} onRoll={handleRoll} />
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Bonus Actions */}
              {selectedCombatant.bonusActions && selectedCombatant.bonusActions.length > 0 && (
                <div className="space-y-2">
                  <div className="h2">Bonus Actions</div>
                  {selectedCombatant.bonusActions.map((action, idx) => (
                    <div key={idx} className="card text-sm">
                      <div className="font-semibold mb-1 dark:text-slate-200">{action.name}</div>
                      <div className="text-slate-700 dark:text-slate-300">
                        <RollableText text={action.desc} onRoll={handleRoll} />
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Reactions */}
              {selectedCombatant.reactions && selectedCombatant.reactions.length > 0 && (
                <div className="space-y-2">
                  <div className="h2">Reactions</div>
                  {selectedCombatant.reactions.map((reaction, idx) => (
                    <div key={idx} className="card text-sm">
                      <div className="font-semibold mb-1 dark:text-slate-200">{reaction.name}</div>
                      <div className="text-slate-700 dark:text-slate-300">
                        <RollableText text={reaction.desc} onRoll={handleRoll} />
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Legendary Actions */}
              {selectedCombatant.legendary && (
                <div className="space-y-2">
                  <div className="h2">Legendary Actions</div>
                  {selectedCombatant.legendary.desc && (
                    <div className="text-sm text-slate-700 dark:text-slate-300 mb-2">
                      <RollableText text={selectedCombatant.legendary.desc} onRoll={handleRoll} />
                    </div>
                  )}
                  {selectedCombatant.legendary.actions?.map((action, idx) => (
                    <div key={idx} className="card text-sm">
                      <div className="font-semibold mb-1 dark:text-slate-200">{action.name}</div>
                      <div className="text-slate-700 dark:text-slate-300">
                        <RollableText text={action.desc} onRoll={handleRoll} />
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Spellcasting */}
              {selectedCombatant.spellcasting && selectedCombatant.spellcasting.length > 0 && (
                <div className="space-y-2">
                  <div className="h2">Spellcasting</div>
                  {selectedCombatant.spellcasting.map((sc, idx) => (
                    <div key={idx} className="card text-sm space-y-1">
                      {sc.name && <div className="font-semibold dark:text-slate-200">{sc.name}</div>}
                      {sc.headerEntries && sc.headerEntries.map((entry, i) => (
                        <div key={i} className="text-slate-700 dark:text-slate-300">
                          <RollableText text={typeof entry === 'string' ? entry : entry.entry || ''} onRoll={handleRoll} />
                        </div>
                      ))}
                      {sc.spells && Object.entries(sc.spells).map(([level, spellData]) => (
                        <div key={level}>
                          <div className="font-medium dark:text-slate-200">{level}</div>
                          <div className="text-slate-700 dark:text-slate-300">
                            {spellData.spells?.join(', ') || ''}
                          </div>
                        </div>
                      ))}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Overlay backdrop */}
      {selectedCombatant && (
        <div
          className="fixed inset-0 bg-black/20 z-20"
          onClick={() => setSelectedCombatantId(null)}
        />
      )}
    </div>
  );
}
